# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp"
# 1 "v:\\GigglingBits\\box2d\\HeyBox2D\\build_heybox2d_vc11//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "v:/GigglingBits/box2d/HeyBox2D/build_heybox2d_vc11/temp_defines_debug.h" 1
# 1 "<command-line>" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp"
# 19 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp"
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h"
# 1 "c:/marmalade/6.3/s3e/h/std/stddef.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 23 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/assert.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/assert.h"
# 1 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/6.3/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 72 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 94 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 106 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 224 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 242 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 254 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2

# 1 "c:/marmalade/6.3/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/6.3/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/6.3/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/6.3/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/6.3/s3e/h/std/assert.h" 2

extern "C" {
# 33 "c:/marmalade/6.3/s3e/h/std/assert.h"
        void __assert(const char* file, int line, const char* expr);
# 43 "c:/marmalade/6.3/s3e/h/std/assert.h"
}
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/float.h" 1
# 31 "c:/marmalade/6.3/s3e/h/std/float.h"
  extern "C" {
# 109 "c:/marmalade/6.3/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/6.3/s3e/h/std/float.h"
    }
# 25 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2




typedef signed char int8;
typedef signed short int16;
typedef signed int int32;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef float float32;
typedef double float64;
# 131 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h"
void* b2Alloc(int32 size);


void b2Free(void* mem);


void b2Log(const char* string, ...);



struct b2Version
{
 int32 major;
 int32 minor;
 int32 revision;
};


extern b2Version b2_version;
# 23 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/math.h" 1
# 17 "c:/marmalade/6.3/s3e/h/std/math.h"
extern "C" {
# 48 "c:/marmalade/6.3/s3e/h/std/math.h"
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);

double sin(double x);
float sinf(float x);
long double sinl(long double x);

double asin(double x);
float asinf(float x);
long double asinl(long double x);

double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);

double cos(double x);
float cosf(float x);
long double cosl(long double x);

double cosh(double x);
float coshf(float x);
long double coshl(long double x);

double acos(double x);
float acosf(float x);
long double acosl(long double x);

double tan(double x);
float tanf(float x);
long double tanl(long double x);

double atan(double x);
float atanf(float x);
long double atanl(long double x);

double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);

double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);

double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);

double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

double floor(double x);
float floorf(float x);
long double floorl(long double x);

double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);

double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);

double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);

double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);

double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);

double modf(double x, double *iptr);
float modff(float x, float *iptr);
long double modfl(long double x, long double *iptr);

double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);

double exp(double x);
float expf(float x);
long double expl(long double x);

double log(double x);
float logf(float x);
long double logl(long double x);

double log10(double x);
float log10f(float x);
long double log10l(long double x);

double rint(double x);
float rintf(float x);
long double rintl(long double x);

double round(double x);
float roundf(float x);
long double roundl(long double x);

double frexp(double x, int *exp);
float frexpf(float x, int *exp);
long double frexpl(long double x, int *exp);

long int lround(double x);
long int lroundf(float x);
long int lroundl(long double x);

int64 llround(double x);
int64 llroundf(float x);
int64 llroundl(long double x);

double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);

double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);

double trunc(double x);
float truncf(float x);
long double truncl(long double x);

double hypot(double x, double y);

double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);

int finite(double x);
# 196 "c:/marmalade/6.3/s3e/h/std/math.h"
# 1 "c:/marmalade/6.3/s3e/h/std/math_gcc.h" 1
# 33 "c:/marmalade/6.3/s3e/h/std/math_gcc.h"
int __isnanf(float);
int __isnand(double);
int __isinff(float);
int __isinfd(double);
int __signbitf(float);
int __signbitd(double);
int __fpclassifyf(float);
int __fpclassifyd(double);
int __fpclassifyl(long double);
# 197 "c:/marmalade/6.3/s3e/h/std/math.h" 2
# 222 "c:/marmalade/6.3/s3e/h/std/math.h"
}
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 2


inline bool b2IsValid(float32 x)
{
 int32 ix = *reinterpret_cast<int32*>(&x);
 return (ix & 0x7f800000) != 0x7f800000;
}


inline float32 b2InvSqrt(float32 x)
{
 union
 {
  float32 x;
  int32 i;
 } convert;

 convert.x = x;
 float32 xhalf = 0.5f * x;
 convert.i = 0x5f3759df - (convert.i >> 1);
 x = convert.x;
 x = x * (1.5f - xhalf * x * x);
 return x;
}





struct b2Vec2
{

 b2Vec2() {}


 b2Vec2(float32 x, float32 y) : x(x), y(y) {}


 void SetZero() { x = 0.0f; y = 0.0f; }


 void Set(float32 x_, float32 y_) { x = x_; y = y_; }


 b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }


 float32 operator () (int32 i) const
 {
  return (&x)[i];
 }


 float32& operator () (int32 i)
 {
  return (&x)[i];
 }


 void operator += (const b2Vec2& v)
 {
  x += v.x; y += v.y;
 }


 void operator -= (const b2Vec2& v)
 {
  x -= v.x; y -= v.y;
 }


 void operator *= (float32 a)
 {
  x *= a; y *= a;
 }


 float32 Length() const
 {
  return sqrtf(x * x + y * y);
 }



 float32 LengthSquared() const
 {
  return x * x + y * y;
 }


 float32 Normalize()
 {
  float32 length = Length();
  if (length < 1.19209290e-7F)
  {
   return 0.0f;
  }
  float32 invLength = 1.0f / length;
  x *= invLength;
  y *= invLength;

  return length;
 }


 bool IsValid() const
 {
  return b2IsValid(x) && b2IsValid(y);
 }


 b2Vec2 Skew() const
 {
  return b2Vec2(-y, x);
 }

 float32 x, y;
};


struct b2Vec3
{

 b2Vec3() {}


 b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}


 void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }


 void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }


 b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }


 void operator += (const b2Vec3& v)
 {
  x += v.x; y += v.y; z += v.z;
 }


 void operator -= (const b2Vec3& v)
 {
  x -= v.x; y -= v.y; z -= v.z;
 }


 void operator *= (float32 s)
 {
  x *= s; y *= s; z *= s;
 }

 float32 x, y, z;
};


struct b2Mat22
{

 b2Mat22() {}


 b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
 {
  ex.x = a11; ex.y = a21;
  ey.x = a12; ey.y = a22;
 }


 void Set(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 void SetIdentity()
 {
  ex.x = 1.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 1.0f;
 }


 void SetZero()
 {
  ex.x = 0.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 0.0f;
 }

 b2Mat22 GetInverse() const
 {
  float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
  b2Mat22 B;
  float32 det = a * d - b * c;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  B.ex.x = det * d; B.ey.x = -det * b;
  B.ex.y = -det * c; B.ey.y = det * a;
  return B;
 }



 b2Vec2 Solve(const b2Vec2& b) const
 {
  float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
  float32 det = a11 * a22 - a12 * a21;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  b2Vec2 x;
  x.x = det * (a22 * b.x - a12 * b.y);
  x.y = det * (a11 * b.y - a21 * b.x);
  return x;
 }

 b2Vec2 ex, ey;
};


struct b2Mat33
{

 b2Mat33() {}


 b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
 {
  ex = c1;
  ey = c2;
  ez = c3;
 }


 void SetZero()
 {
  ex.SetZero();
  ey.SetZero();
  ez.SetZero();
 }



 b2Vec3 Solve33(const b2Vec3& b) const;




 b2Vec2 Solve22(const b2Vec2& b) const;



 void GetInverse22(b2Mat33* M) const;



 void GetSymInverse33(b2Mat33* M) const;

 b2Vec3 ex, ey, ez;
};


struct b2Rot
{
 b2Rot() {}


 explicit b2Rot(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void Set(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void SetIdentity()
 {
  s = 0.0f;
  c = 1.0f;
 }


 float32 GetAngle() const
 {
  return atan2f(s, c);
 }


 b2Vec2 GetXAxis() const
 {
  return b2Vec2(c, s);
 }


 b2Vec2 GetYAxis() const
 {
  return b2Vec2(-s, c);
 }


 float32 s, c;
};



struct b2Transform
{

 b2Transform() {}


 b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}


 void SetIdentity()
 {
  p.SetZero();
  q.SetIdentity();
 }


 void Set(const b2Vec2& position, float32 angle)
 {
  p = position;
  q.Set(angle);
 }

 b2Vec2 p;
 b2Rot q;
};





struct b2Sweep
{


 void GetTransform(b2Transform* xfb, float32 beta) const;



 void Advance(float32 alpha);


 void Normalize();

 b2Vec2 localCenter;
 b2Vec2 c0, c;
 float32 a0, a;



 float32 alpha0;
};


extern const b2Vec2 b2Vec2_zero;


inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.x + a.y * b.y;
}


inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.y - a.y * b.x;
}



inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
{
 return b2Vec2(s * a.y, -s * a.x);
}



inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
{
 return b2Vec2(-s * a.y, s * a.x);
}



inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}



inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
}


inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x + b.x, a.y + b.y);
}


inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x - b.x, a.y - b.y);
}

inline b2Vec2 operator * (float32 s, const b2Vec2& a)
{
 return b2Vec2(s * a.x, s * a.y);
}

inline bool operator == (const b2Vec2& a, const b2Vec2& b)
{
 return a.x == b.x && a.y == b.y;
}

inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return c.Length();
}

inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return b2Dot(c, c);
}

inline b2Vec3 operator * (float32 s, const b2Vec3& a)
{
 return b2Vec3(s * a.x, s * a.y, s * a.z);
}


inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
}


inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
}


inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z;
}


inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(A.ex + B.ex, A.ey + B.ey);
}


inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
}


inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
{
 b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
 b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
 return b2Mat22(c1, c2);
}


inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
{
 return v.x * A.ex + v.y * A.ey + v.z * A.ez;
}


inline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}


inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.s * r.c + q.c * r.s;
 qr.c = q.c * r.c - q.s * r.s;
 return qr;
}


inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.c * r.s - q.s * r.c;
 qr.c = q.c * r.c + q.s * r.s;
 return qr;
}


inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
}


inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
}

inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
{
 float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
 float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;

 return b2Vec2(x, y);
}

inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
{
 float32 px = v.x - T.p.x;
 float32 py = v.y - T.p.y;
 float32 x = (T.q.c * px + T.q.s * py);
 float32 y = (-T.q.s * px + T.q.c * py);

 return b2Vec2(x, y);
}



inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2Mul(A.q, B.q);
 C.p = b2Mul(A.q, B.p) + A.p;
 return C;
}



inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2MulT(A.q, B.q);
 C.p = b2MulT(A.q, B.p - A.p);
 return C;
}

template <typename T>
inline T b2Abs(T a)
{
 return a > T(0) ? a : -a;
}

inline b2Vec2 b2Abs(const b2Vec2& a)
{
 return b2Vec2(b2Abs(a.x), b2Abs(a.y));
}

inline b2Mat22 b2Abs(const b2Mat22& A)
{
 return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
}

template <typename T>
inline T b2Min(T a, T b)
{
 return a < b ? a : b;
}

inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
}

template <typename T>
inline T b2Max(T a, T b)
{
 return a > b ? a : b;
}

inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
}

template <typename T>
inline T b2Clamp(T a, T low, T high)
{
 return b2Max(low, b2Min(a, high));
}

inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
{
 return b2Max(low, b2Min(a, high));
}

template<typename T> inline void b2Swap(T& a, T& b)
{
 T tmp = a;
 a = b;
 b = tmp;
}






inline uint32 b2NextPowerOfTwo(uint32 x)
{
 x |= (x >> 1);
 x |= (x >> 2);
 x |= (x >> 4);
 x |= (x >> 8);
 x |= (x >> 16);
 return x + 1;
}

inline bool b2IsPowerOfTwo(uint32 x)
{
 bool result = x > 0 && (x & (x - 1)) == 0;
 return result;
}

inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
{
 xf->p = (1.0f - beta) * c0 + beta * c;
 float32 angle = (1.0f - beta) * a0 + beta * a;
 xf->q.Set(angle);


 xf->p -= b2Mul(xf->q, localCenter);
}

inline void b2Sweep::Advance(float32 alpha)
{
 ((alpha0 < 1.0f) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Common/b2Math.h", 704, "alpha0 < 1.0f"));
 float32 beta = (alpha - alpha0) / (1.0f - alpha0);
 c0 += beta * (c - c0);
 a0 += beta * (a - a0);
 alpha0 = alpha;
}


inline void b2Sweep::Normalize()
{
 float32 twoPi = 2.0f * 3.14159265359f;
 float32 d = twoPi * floorf(a0 / twoPi);
 a0 -= d;
 a -= d;
}
# 23 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.h" 2

class b2Body;
class b2Joint;
struct b2SolverData;
class b2BlockAllocator;

enum b2JointType
{
 e_unknownJoint,
 e_revoluteJoint,
 e_prismaticJoint,
 e_distanceJoint,
 e_pulleyJoint,
 e_mouseJoint,
 e_gearJoint,
 e_wheelJoint,
    e_weldJoint,
 e_frictionJoint,
 e_ropeJoint,
 e_motorJoint
};

enum b2LimitState
{
 e_inactiveLimit,
 e_atLowerLimit,
 e_atUpperLimit,
 e_equalLimits
};

struct b2Jacobian
{
 b2Vec2 linear;
 float32 angularA;
 float32 angularB;
};






struct b2JointEdge
{
 b2Body* other;
 b2Joint* joint;
 b2JointEdge* prev;
 b2JointEdge* next;
};


struct b2JointDef
{
 b2JointDef()
 {
  type = e_unknownJoint;
  userData = __null;
  bodyA = __null;
  bodyB = __null;
  collideConnected = false;
 }


 b2JointType type;


 void* userData;


 b2Body* bodyA;


 b2Body* bodyB;


 bool collideConnected;
};



class b2Joint
{
public:


 b2JointType GetType() const;


 b2Body* GetBodyA();


 b2Body* GetBodyB();


 virtual b2Vec2 GetAnchorA() const = 0;


 virtual b2Vec2 GetAnchorB() const = 0;


 virtual b2Vec2 GetReactionForce(float32 inv_dt) const = 0;


 virtual float32 GetReactionTorque(float32 inv_dt) const = 0;


 b2Joint* GetNext();
 const b2Joint* GetNext() const;


 void* GetUserData() const;


 void SetUserData(void* data);


 bool IsActive() const;




 bool GetCollideConnected() const;


 virtual void Dump() { b2Log("// Dump is not supported for this joint type.\n"); }


 virtual void ShiftOrigin(const b2Vec2& newOrigin) { ((void)(newOrigin)); }

protected:
 friend class b2World;
 friend class b2Body;
 friend class b2Island;
 friend class b2GearJoint;

 static b2Joint* Create(const b2JointDef* def, b2BlockAllocator* allocator);
 static void Destroy(b2Joint* joint, b2BlockAllocator* allocator);

 b2Joint(const b2JointDef* def);
 virtual ~b2Joint() {}

 virtual void InitVelocityConstraints(const b2SolverData& data) = 0;
 virtual void SolveVelocityConstraints(const b2SolverData& data) = 0;


 virtual bool SolvePositionConstraints(const b2SolverData& data) = 0;

 b2JointType m_type;
 b2Joint* m_prev;
 b2Joint* m_next;
 b2JointEdge m_edgeA;
 b2JointEdge m_edgeB;
 b2Body* m_bodyA;
 b2Body* m_bodyB;

 int32 m_index;

 bool m_islandFlag;
 bool m_collideConnected;

 void* m_userData;
};

inline b2JointType b2Joint::GetType() const
{
 return m_type;
}

inline b2Body* b2Joint::GetBodyA()
{
 return m_bodyA;
}

inline b2Body* b2Joint::GetBodyB()
{
 return m_bodyB;
}

inline b2Joint* b2Joint::GetNext()
{
 return m_next;
}

inline const b2Joint* b2Joint::GetNext() const
{
 return m_next;
}

inline void* b2Joint::GetUserData() const
{
 return m_userData;
}

inline void b2Joint::SetUserData(void* data)
{
 m_userData = data;
}

inline bool b2Joint::GetCollideConnected() const
{
 return m_collideConnected;
}
# 20 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2DistanceJoint.h" 1
# 30 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2DistanceJoint.h"
struct b2DistanceJointDef : public b2JointDef
{
 b2DistanceJointDef()
 {
  type = e_distanceJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  length = 1.0f;
  frequencyHz = 0.0f;
  dampingRatio = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB,
     const b2Vec2& anchorA, const b2Vec2& anchorB);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 length;



 float32 frequencyHz;


 float32 dampingRatio;
};




class b2DistanceJoint : public b2Joint
{
public:

 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;



 b2Vec2 GetReactionForce(float32 inv_dt) const;



 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }



 void SetLength(float32 length);
 float32 GetLength() const;


 void SetFrequency(float32 hz);
 float32 GetFrequency() const;


 void SetDampingRatio(float32 ratio);
 float32 GetDampingRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2DistanceJoint(const b2DistanceJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_bias;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_gamma;
 float32 m_impulse;
 float32 m_length;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_u;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
};

inline void b2DistanceJoint::SetLength(float32 length)
{
 m_length = length;
}

inline float32 b2DistanceJoint::GetLength() const
{
 return m_length;
}

inline void b2DistanceJoint::SetFrequency(float32 hz)
{
 m_frequencyHz = hz;
}

inline float32 b2DistanceJoint::GetFrequency() const
{
 return m_frequencyHz;
}

inline void b2DistanceJoint::SetDampingRatio(float32 ratio)
{
 m_dampingRatio = ratio;
}

inline float32 b2DistanceJoint::GetDampingRatio() const
{
 return m_dampingRatio;
}
# 21 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2WheelJoint.h" 1
# 30 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2WheelJoint.h"
struct b2WheelJointDef : public b2JointDef
{
 b2WheelJointDef()
 {
  type = e_wheelJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  localAxisA.Set(1.0f, 0.0f);
  enableMotor = false;
  maxMotorTorque = 0.0f;
  motorSpeed = 0.0f;
  frequencyHz = 2.0f;
  dampingRatio = 0.7f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 b2Vec2 localAxisA;


 bool enableMotor;


 float32 maxMotorTorque;


 float32 motorSpeed;


 float32 frequencyHz;


 float32 dampingRatio;
};






class b2WheelJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }


 float32 GetJointTranslation() const;


 float32 GetJointSpeed() const;


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorTorque(float32 torque);
 float32 GetMaxMotorTorque() const;


 float32 GetMotorTorque(float32 inv_dt) const;


 void SetSpringFrequencyHz(float32 hz);
 float32 GetSpringFrequencyHz() const;


 void SetSpringDampingRatio(float32 ratio);
 float32 GetSpringDampingRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2WheelJoint(const b2WheelJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localXAxisA;
 b2Vec2 m_localYAxisA;

 float32 m_impulse;
 float32 m_motorImpulse;
 float32 m_springImpulse;

 float32 m_maxMotorTorque;
 float32 m_motorSpeed;
 bool m_enableMotor;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;

 b2Vec2 m_ax, m_ay;
 float32 m_sAx, m_sBx;
 float32 m_sAy, m_sBy;

 float32 m_mass;
 float32 m_motorMass;
 float32 m_springMass;

 float32 m_bias;
 float32 m_gamma;
};

inline float32 b2WheelJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}

inline float32 b2WheelJoint::GetMaxMotorTorque() const
{
 return m_maxMotorTorque;
}

inline void b2WheelJoint::SetSpringFrequencyHz(float32 hz)
{
 m_frequencyHz = hz;
}

inline float32 b2WheelJoint::GetSpringFrequencyHz() const
{
 return m_frequencyHz;
}

inline void b2WheelJoint::SetSpringDampingRatio(float32 ratio)
{
 m_dampingRatio = ratio;
}

inline float32 b2WheelJoint::GetSpringDampingRatio() const
{
 return m_dampingRatio;
}
# 22 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2MouseJoint.h" 1
# 26 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2MouseJoint.h"
struct b2MouseJointDef : public b2JointDef
{
 b2MouseJointDef()
 {
  type = e_mouseJoint;
  target.Set(0.0f, 0.0f);
  maxForce = 0.0f;
  frequencyHz = 5.0f;
  dampingRatio = 0.7f;
 }



 b2Vec2 target;




 float32 maxForce;


 float32 frequencyHz;


 float32 dampingRatio;
};
# 60 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2MouseJoint.h"
class b2MouseJoint : public b2Joint
{
public:


 b2Vec2 GetAnchorA() const;


 b2Vec2 GetAnchorB() const;


 b2Vec2 GetReactionForce(float32 inv_dt) const;


 float32 GetReactionTorque(float32 inv_dt) const;


 void SetTarget(const b2Vec2& target);
 const b2Vec2& GetTarget() const;


 void SetMaxForce(float32 force);
 float32 GetMaxForce() const;


 void SetFrequency(float32 hz);
 float32 GetFrequency() const;


 void SetDampingRatio(float32 ratio);
 float32 GetDampingRatio() const;


 void Dump() { b2Log("Mouse joint dumping is not supported.\n"); }


 void ShiftOrigin(const b2Vec2& newOrigin);

protected:
 friend class b2Joint;

 b2MouseJoint(const b2MouseJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_localAnchorB;
 b2Vec2 m_targetA;
 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_beta;


 b2Vec2 m_impulse;
 float32 m_maxForce;
 float32 m_gamma;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterB;
 float32 m_invMassB;
 float32 m_invIB;
 b2Mat22 m_mass;
 b2Vec2 m_C;
};
# 23 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2RevoluteJoint.h" 1
# 35 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2RevoluteJoint.h"
struct b2RevoluteJointDef : public b2JointDef
{
 b2RevoluteJointDef()
 {
  type = e_revoluteJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  referenceAngle = 0.0f;
  lowerAngle = 0.0f;
  upperAngle = 0.0f;
  maxMotorTorque = 0.0f;
  motorSpeed = 0.0f;
  enableLimit = false;
  enableMotor = false;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 referenceAngle;


 bool enableLimit;


 float32 lowerAngle;


 float32 upperAngle;


 bool enableMotor;


 float32 motorSpeed;



 float32 maxMotorTorque;
};







class b2RevoluteJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 float32 GetJointAngle() const;


 float32 GetJointSpeed() const;


 bool IsLimitEnabled() const;


 void EnableLimit(bool flag);


 float32 GetLowerLimit() const;


 float32 GetUpperLimit() const;


 void SetLimits(float32 lower, float32 upper);


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorTorque(float32 torque);
 float32 GetMaxMotorTorque() const { return m_maxMotorTorque; }



 b2Vec2 GetReactionForce(float32 inv_dt) const;



 float32 GetReactionTorque(float32 inv_dt) const;



 float32 GetMotorTorque(float32 inv_dt) const;


 void Dump();

protected:

 friend class b2Joint;
 friend class b2GearJoint;

 b2RevoluteJoint(const b2RevoluteJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec3 m_impulse;
 float32 m_motorImpulse;

 bool m_enableMotor;
 float32 m_maxMotorTorque;
 float32 m_motorSpeed;

 bool m_enableLimit;
 float32 m_referenceAngle;
 float32 m_lowerAngle;
 float32 m_upperAngle;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat33 m_mass;
 float32 m_motorMass;
 b2LimitState m_limitState;
};

inline float32 b2RevoluteJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}
# 24 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2PrismaticJoint.h" 1
# 30 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2PrismaticJoint.h"
struct b2PrismaticJointDef : public b2JointDef
{
 b2PrismaticJointDef()
 {
  type = e_prismaticJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  localAxisA.Set(1.0f, 0.0f);
  referenceAngle = 0.0f;
  enableLimit = false;
  lowerTranslation = 0.0f;
  upperTranslation = 0.0f;
  enableMotor = false;
  maxMotorForce = 0.0f;
  motorSpeed = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 b2Vec2 localAxisA;


 float32 referenceAngle;


 bool enableLimit;


 float32 lowerTranslation;


 float32 upperTranslation;


 bool enableMotor;


 float32 maxMotorForce;


 float32 motorSpeed;
};





class b2PrismaticJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 float32 GetJointTranslation() const;


 float32 GetJointSpeed() const;


 bool IsLimitEnabled() const;


 void EnableLimit(bool flag);


 float32 GetLowerLimit() const;


 float32 GetUpperLimit() const;


 void SetLimits(float32 lower, float32 upper);


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorForce(float32 force);
 float32 GetMaxMotorForce() const { return m_maxMotorForce; }


 float32 GetMotorForce(float32 inv_dt) const;


 void Dump();

protected:
 friend class b2Joint;
 friend class b2GearJoint;
 b2PrismaticJoint(const b2PrismaticJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localXAxisA;
 b2Vec2 m_localYAxisA;
 float32 m_referenceAngle;
 b2Vec3 m_impulse;
 float32 m_motorImpulse;
 float32 m_lowerTranslation;
 float32 m_upperTranslation;
 float32 m_maxMotorForce;
 float32 m_motorSpeed;
 bool m_enableLimit;
 bool m_enableMotor;
 b2LimitState m_limitState;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Vec2 m_axis, m_perp;
 float32 m_s1, m_s2;
 float32 m_a1, m_a2;
 b2Mat33 m_K;
 float32 m_motorMass;
};

inline float32 b2PrismaticJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2PulleyJoint.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2PulleyJoint.h"
const float32 b2_minPulleyLength = 2.0f;



struct b2PulleyJointDef : public b2JointDef
{
 b2PulleyJointDef()
 {
  type = e_pulleyJoint;
  groundAnchorA.Set(-1.0f, 1.0f);
  groundAnchorB.Set(1.0f, 1.0f);
  localAnchorA.Set(-1.0f, 0.0f);
  localAnchorB.Set(1.0f, 0.0f);
  lengthA = 0.0f;
  lengthB = 0.0f;
  ratio = 1.0f;
  collideConnected = true;
 }


 void Initialize(b2Body* bodyA, b2Body* bodyB,
     const b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,
     const b2Vec2& anchorA, const b2Vec2& anchorB,
     float32 ratio);


 b2Vec2 groundAnchorA;


 b2Vec2 groundAnchorB;


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 lengthA;


 float32 lengthB;


 float32 ratio;
};
# 79 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2PulleyJoint.h"
class b2PulleyJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 b2Vec2 GetGroundAnchorA() const;


 b2Vec2 GetGroundAnchorB() const;


 float32 GetLengthA() const;


 float32 GetLengthB() const;


 float32 GetRatio() const;


 float32 GetCurrentLengthA() const;


 float32 GetCurrentLengthB() const;


 void Dump();


 void ShiftOrigin(const b2Vec2& newOrigin);

protected:

 friend class b2Joint;
 b2PulleyJoint(const b2PulleyJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_groundAnchorA;
 b2Vec2 m_groundAnchorB;
 float32 m_lengthA;
 float32 m_lengthB;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_constant;
 float32 m_ratio;
 float32 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_uA;
 b2Vec2 m_uB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
};
# 26 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2GearJoint.h" 1
# 26 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2GearJoint.h"
struct b2GearJointDef : public b2JointDef
{
 b2GearJointDef()
 {
  type = e_gearJoint;
  joint1 = __null;
  joint2 = __null;
  ratio = 1.0f;
 }


 b2Joint* joint1;


 b2Joint* joint2;



 float32 ratio;
};
# 56 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2GearJoint.h"
class b2GearJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 b2Joint* GetJoint1() { return m_joint1; }


 b2Joint* GetJoint2() { return m_joint2; }


 void SetRatio(float32 ratio);
 float32 GetRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2GearJoint(const b2GearJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Joint* m_joint1;
 b2Joint* m_joint2;

 b2JointType m_typeA;
 b2JointType m_typeB;



 b2Body* m_bodyC;
 b2Body* m_bodyD;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localAnchorC;
 b2Vec2 m_localAnchorD;

 b2Vec2 m_localAxisC;
 b2Vec2 m_localAxisD;

 float32 m_referenceAngleA;
 float32 m_referenceAngleB;

 float32 m_constant;
 float32 m_ratio;

 float32 m_impulse;


 int32 m_indexA, m_indexB, m_indexC, m_indexD;
 b2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;
 float32 m_mA, m_mB, m_mC, m_mD;
 float32 m_iA, m_iB, m_iC, m_iD;
 b2Vec2 m_JvAC, m_JvBD;
 float32 m_JwA, m_JwB, m_JwC, m_JwD;
 float32 m_mass;
};
# 27 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2WeldJoint.h" 1
# 27 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2WeldJoint.h"
struct b2WeldJointDef : public b2JointDef
{
 b2WeldJointDef()
 {
  type = e_weldJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  referenceAngle = 0.0f;
  frequencyHz = 0.0f;
  dampingRatio = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 referenceAngle;



 float32 frequencyHz;


 float32 dampingRatio;
};



class b2WeldJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 void SetFrequency(float32 hz) { m_frequencyHz = hz; }
 float32 GetFrequency() const { return m_frequencyHz; }


 void SetDampingRatio(float32 ratio) { m_dampingRatio = ratio; }
 float32 GetDampingRatio() const { return m_dampingRatio; }


 void Dump();

protected:

 friend class b2Joint;

 b2WeldJoint(const b2WeldJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_bias;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_referenceAngle;
 float32 m_gamma;
 b2Vec3 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat33 m_mass;
};
# 28 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2FrictionJoint.h" 1
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2FrictionJoint.h"
struct b2FrictionJointDef : public b2JointDef
{
 b2FrictionJointDef()
 {
  type = e_frictionJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  maxForce = 0.0f;
  maxTorque = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 maxForce;


 float32 maxTorque;
};



class b2FrictionJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 void SetMaxForce(float32 force);


 float32 GetMaxForce() const;


 void SetMaxTorque(float32 torque);


 float32 GetMaxTorque() const;


 void Dump();

protected:

 friend class b2Joint;

 b2FrictionJoint(const b2FrictionJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;


 b2Vec2 m_linearImpulse;
 float32 m_angularImpulse;
 float32 m_maxForce;
 float32 m_maxTorque;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat22 m_linearMass;
 float32 m_angularMass;
};
# 29 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2RopeJoint.h" 1
# 28 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2RopeJoint.h"
struct b2RopeJointDef : public b2JointDef
{
 b2RopeJointDef()
 {
  type = e_ropeJoint;
  localAnchorA.Set(-1.0f, 0.0f);
  localAnchorB.Set(1.0f, 0.0f);
  maxLength = 0.0f;
 }


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;




 float32 maxLength;
};
# 58 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2RopeJoint.h"
class b2RopeJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 void SetMaxLength(float32 length) { m_maxLength = length; }
 float32 GetMaxLength() const;

 b2LimitState GetLimitState() const;


 void Dump();

protected:

 friend class b2Joint;
 b2RopeJoint(const b2RopeJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_maxLength;
 float32 m_length;
 float32 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_u;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
 b2LimitState m_state;
};
# 30 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2MotorJoint.h" 1
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2MotorJoint.h"
struct b2MotorJointDef : public b2JointDef
{
 b2MotorJointDef()
 {
  type = e_motorJoint;
  linearOffset.SetZero();
  angularOffset = 0.0f;
  maxForce = 1.0f;
  maxTorque = 1.0f;
  correctionFactor = 0.3f;
 }


 void Initialize(b2Body* bodyA, b2Body* bodyB);


 b2Vec2 linearOffset;


 float32 angularOffset;


 float32 maxForce;


 float32 maxTorque;


 float32 correctionFactor;
};




class b2MotorJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 void SetLinearOffset(const b2Vec2& linearOffset);
 const b2Vec2& GetLinearOffset() const;


 void SetAngularOffset(float32 angularOffset);
 float32 GetAngularOffset() const;


 void SetMaxForce(float32 force);


 float32 GetMaxForce() const;


 void SetMaxTorque(float32 torque);


 float32 GetMaxTorque() const;


 void SetCorrectionFactor(float32 factor);


 float32 GetCorrectionFactor() const;


 void Dump();

protected:

 friend class b2Joint;

 b2MotorJoint(const b2MotorJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_linearOffset;
 float32 m_angularOffset;
 b2Vec2 m_linearImpulse;
 float32 m_angularImpulse;
 float32 m_maxForce;
 float32 m_maxTorque;
 float32 m_correctionFactor;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 b2Vec2 m_linearError;
 float32 m_angularError;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat22 m_linearMass;
 float32 m_angularMass;
};
# 31 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h" 1
# 23 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h"
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2BlockAllocator.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2BlockAllocator.h"
const int32 b2_chunkSize = 16 * 1024;
const int32 b2_maxBlockSize = 640;
const int32 b2_blockSizes = 14;
const int32 b2_chunkArrayIncrement = 128;

struct b2Block;
struct b2Chunk;




class b2BlockAllocator
{
public:
 b2BlockAllocator();
 ~b2BlockAllocator();


 void* Allocate(int32 size);


 void Free(void* p, int32 size);

 void Clear();

private:

 b2Chunk* m_chunks;
 int32 m_chunkCount;
 int32 m_chunkSpace;

 b2Block* m_freeLists[b2_blockSizes];

 static int32 s_blockSizes[b2_blockSizes];
 static uint8 s_blockSizeLookup[b2_maxBlockSize + 1];
 static bool s_blockSizeLookupInitialized;
};
# 23 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 2

# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h" 1
# 23 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
# 1 "c:/marmalade/6.3/s3e/h/std/limits.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h" 2





class b2Shape;
class b2CircleShape;
class b2EdgeShape;
class b2PolygonShape;

const uint8 b2_nullFeature = 255;



struct b2ContactFeature
{
 enum Type
 {
  e_vertex = 0,
  e_face = 1
 };

 uint8 indexA;
 uint8 indexB;
 uint8 typeA;
 uint8 typeB;
};


union b2ContactID
{
 b2ContactFeature cf;
 uint32 key;
};
# 69 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
struct b2ManifoldPoint
{
 b2Vec2 localPoint;
 float32 normalImpulse;
 float32 tangentImpulse;
 b2ContactID id;
};
# 93 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
struct b2Manifold
{
 enum Type
 {
  e_circles,
  e_faceA,
  e_faceB
 };

 b2ManifoldPoint points[2];
 b2Vec2 localNormal;
 b2Vec2 localPoint;
 Type type;
 int32 pointCount;
};


struct b2WorldManifold
{




 void Initialize(const b2Manifold* manifold,
     const b2Transform& xfA, float32 radiusA,
     const b2Transform& xfB, float32 radiusB);

 b2Vec2 normal;
 b2Vec2 points[2];
 float32 separations[2];
};


enum b2PointState
{
 b2_nullState,
 b2_addState,
 b2_persistState,
 b2_removeState
};



void b2GetPointStates(b2PointState state1[2], b2PointState state2[2],
       const b2Manifold* manifold1, const b2Manifold* manifold2);


struct b2ClipVertex
{
 b2Vec2 v;
 b2ContactID id;
};


struct b2RayCastInput
{
 b2Vec2 p1, p2;
 float32 maxFraction;
};



struct b2RayCastOutput
{
 b2Vec2 normal;
 float32 fraction;
};


struct b2AABB
{

 bool IsValid() const;


 b2Vec2 GetCenter() const
 {
  return 0.5f * (lowerBound + upperBound);
 }


 b2Vec2 GetExtents() const
 {
  return 0.5f * (upperBound - lowerBound);
 }


 float32 GetPerimeter() const
 {
  float32 wx = upperBound.x - lowerBound.x;
  float32 wy = upperBound.y - lowerBound.y;
  return 2.0f * (wx + wy);
 }


 void Combine(const b2AABB& aabb)
 {
  lowerBound = b2Min(lowerBound, aabb.lowerBound);
  upperBound = b2Max(upperBound, aabb.upperBound);
 }


 void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
 {
  lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
  upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
 }


 bool Contains(const b2AABB& aabb) const
 {
  bool result = true;
  result = result && lowerBound.x <= aabb.lowerBound.x;
  result = result && lowerBound.y <= aabb.lowerBound.y;
  result = result && aabb.upperBound.x <= upperBound.x;
  result = result && aabb.upperBound.y <= upperBound.y;
  return result;
 }

 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;

 b2Vec2 lowerBound;
 b2Vec2 upperBound;
};


void b2CollideCircles(b2Manifold* manifold,
       const b2CircleShape* circleA, const b2Transform& xfA,
       const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygonAndCircle(b2Manifold* manifold,
          const b2PolygonShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygons(b2Manifold* manifold,
        const b2PolygonShape* polygonA, const b2Transform& xfA,
        const b2PolygonShape* polygonB, const b2Transform& xfB);


void b2CollideEdgeAndCircle(b2Manifold* manifold,
          const b2EdgeShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollideEdgeAndPolygon(b2Manifold* manifold,
          const b2EdgeShape* edgeA, const b2Transform& xfA,
          const b2PolygonShape* circleB, const b2Transform& xfB);


int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
       const b2Vec2& normal, float32 offset, int32 vertexIndexA);


bool b2TestOverlap( const b2Shape* shapeA, int32 indexA,
     const b2Shape* shapeB, int32 indexB,
     const b2Transform& xfA, const b2Transform& xfB);



inline bool b2AABB::IsValid() const
{
 b2Vec2 d = upperBound - lowerBound;
 bool valid = d.x >= 0.0f && d.y >= 0.0f;
 valid = valid && lowerBound.IsValid() && upperBound.IsValid();
 return valid;
}

inline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)
{
 b2Vec2 d1, d2;
 d1 = b.lowerBound - a.upperBound;
 d2 = a.lowerBound - b.upperBound;

 if (d1.x > 0.0f || d1.y > 0.0f)
  return false;

 if (d2.x > 0.0f || d2.y > 0.0f)
  return false;

 return true;
}
# 25 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 2


struct b2MassData
{

 float32 mass;


 b2Vec2 center;


 float32 I;
};




class b2Shape
{
public:

 enum Type
 {
  e_circle = 0,
  e_edge = 1,
  e_polygon = 2,
  e_chain = 3,
  e_typeCount = 4
 };

 virtual ~b2Shape() {}


 virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;



 Type GetType() const;


 virtual int32 GetChildCount() const = 0;




 virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;






 virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
      const b2Transform& transform, int32 childIndex) const = 0;





 virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;





 virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;

 Type m_type;
 float32 m_radius;
};

inline b2Shape::Type b2Shape::GetType() const
{
 return m_type;
}
# 24 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/c++/memory" 1
# 24 "c:/marmalade/6.3/s3e/h/std/c++/memory"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/6.3/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/6.3/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/6.3/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2



         



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 1
# 31 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/6.3/s3e/h/ext/../std/stddef.h" 1
# 38 "c:/marmalade/6.3/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 32 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2







# 1 "c:/marmalade/6.3/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/6.3/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/6.3/s3e/h/ext/../std/stdlib.h" 1
# 16 "c:/marmalade/6.3/s3e/h/ext/../std/stdlib.h"
# 1 "c:/marmalade/6.3/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/6.3/s3e/h/std/malloc.h"
# 1 "c:/marmalade/6.3/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/6.3/s3e/h/std/alloca.h"
extern "C" {


    extern void *alloca(size_t __size);
# 35 "c:/marmalade/6.3/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/6.3/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/6.3/s3e/h/ext/../std/stdlib.h" 2
# 28 "c:/marmalade/6.3/s3e/h/ext/../std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void) __attribute__ ((noreturn));
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 112 "c:/marmalade/6.3/s3e/h/ext/../std/stdlib.h"
}
# 28 "c:/marmalade/6.3/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/6.3/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/6.3/s3e/h/std/c++/cstdlib"
}
# 40 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2


# 1 "c:/marmalade/6.3/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/6.3/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/6.3/s3e/h/ext/../std/string.h" 1
# 17 "c:/marmalade/6.3/s3e/h/ext/../std/string.h"
extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);
# 34 "c:/marmalade/6.3/s3e/h/ext/../std/string.h"
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

char* strnstr(const char *s, const char *find, size_t slen);

}
# 28 "c:/marmalade/6.3/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/6.3/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/6.3/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/6.3/s3e/h/std/c++/cstring" 2
}
# 43 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2





# 1 "c:/marmalade/6.3/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/6.3/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h" 1
# 19 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h"
extern "C" {
# 54 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 73 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/6.3/s3e/h/std/stdarg.h" 1
# 54 "c:/marmalade/6.3/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 169 "c:/marmalade/6.3/s3e/h/ext/../std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 36 "c:/marmalade/6.3/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/6.3/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/6.3/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2
# 60 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/6.3/s3e/h/std/c++/exception"
# 1 "c:/marmalade/6.3/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/6.3/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/exception_gcc" 1
# 41 "c:/marmalade/6.3/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "c:/marmalade/6.3/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/6.3/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/6.3/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "c:/marmalade/6.3/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/6.3/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/6.3/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.3/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/new" 1
# 38 "c:/marmalade/6.3/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/6.3/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/6.3/s3e/h/std/c++/new" 2
# 51 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/6.3/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 61 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/6.3/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h" 1
# 43 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/6.3/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 44 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h" 2


namespace _STL {
# 55 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/6.3/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/6.3/s3e/h/std/c++/stl/_alloc.h"
}
# 33 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.h" 1
# 34 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/climits" 1
# 35 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.h" 2





# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_uninitialized.h" 1
# 38 "c:/marmalade/6.3/s3e/h/std/c++/stl/_uninitialized.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h" 1
# 51 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/6.3/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h" 2






namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/6.3/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algobase.h" 2
# 39 "c:/marmalade/6.3/s3e/h/std/c++/stl/_uninitialized.h" 2






namespace _STL {





template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __true_type&) {
  return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

template <class _InputIter, class _ForwardIter>
inline
_ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __false_type&)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return __cur;
  }
  ;



}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
  return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
  return (char*)__copy_trivial (__first, __last, __result);
}


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
  return (wchar_t*)__copy_trivial (__first, __last, __result);
}





template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
                       _ForwardIter __result,
                       const input_iterator_tag &)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  ;



}
# 135 "c:/marmalade/6.3/s3e/h/std/c++/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
                                                                             typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type()));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
                     _ForwardIter __result) {
  return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}




template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __true_type&) {
  _STL::fill(__first, __last, __x);
}

template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Construct(&*__cur, __x);
  }
  ;
}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}



template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __true_type&) {
  return _STL::fill_n(__first, __n, __x);
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Construct(&*__cur, __x);
    return __cur;
  }
  ;



}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}
# 219 "c:/marmalade/6.3/s3e/h/std/c++/stl/_uninitialized.h"
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __true_type)
{
  return __uninitialized_copy(__first2, __last2,
                              __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __false_type)
{
  _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  {
    return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  }
  ;



}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  __uninitialized_fill(__result, __mid, __x, _I_POD());
  {
    return __uninitialized_copy(__first, __last, __mid, _I_POD());
  }
  ;



}




template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                          _ForwardIter __first2, _ForwardIter __last2,
                          const _Tp& __x)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
  {
    __uninitialized_fill(__mid2, __last2, __x, _I_POD());
  }
  ;
}

}
# 41 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.h" 2


namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}



template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffffL / sizeof(_Tp)))
      _M_len = 0x7fffffffL / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {




     typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

    {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    ;
  }

  ~_Temporary_buffer() {
    _STL::_Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type

         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};



}


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.c" 1
# 33 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.c"
namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffffL / sizeof(_Tp)))
    __len = 0x7fffffffL / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}
# 159 "c:/marmalade/6.3/s3e/h/std/c++/stl/_tempbuf.h" 2
# 37 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_raw_storage_iter.h" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/stl/_raw_storage_iter.h"
namespace _STL {

template <class _ForwardIterator, class _Tp>
class raw_storage_iterator



{
protected:
  _ForwardIterator _M_iter;
public:
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
  raw_storage_iterator<_ForwardIterator, _Tp>& operator*() { return *this; }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator=(const _Tp& __element) {
    _Construct(&*_M_iter, __element);
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
    ++_M_iter;
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
    ++_M_iter;
    return __tmp;
  }
};





}
# 41 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_auto_ptr.h" 1
# 22 "c:/marmalade/6.3/s3e/h/std/c++/stl/_auto_ptr.h"
namespace _STL {

class __ptr_base {
public:
  void* _M_p;
  void __set(const void* p) { _M_p = const_cast<void*>(p); }
  void __set(void* p) { _M_p = p; }
};

template <class _Tp> class auto_ptr_ref {
public:
  __ptr_base& _M_r;
  _Tp* const _M_p;

  auto_ptr_ref(__ptr_base& __r, _Tp* __p) : _M_r(__r), _M_p(__p) { }

  _Tp* release() const { _M_r.__set((void*)0); return _M_p; }

};

template<class _Tp> class auto_ptr : public __ptr_base {
public:
  typedef _Tp element_type;
  typedef auto_ptr<_Tp> _Self;

  _Tp* release() {
    _Tp* __px = this->get();
    this->_M_p = 0;
    return __px;
  }

  void reset(_Tp* __px=0) {
    _Tp* __pt = this->get();
    if (__px != __pt)
      delete __pt;
    this->__set(__px);
  }

  _Tp* get() const { return reinterpret_cast<_Tp*>(const_cast<void*>(_M_p)); }


  _Tp* operator->() const {
   
    return get();
  }

  _Tp& operator*() const {
   
    return *get();
  }

  auto_ptr() { this->_M_p = 0; }

  explicit auto_ptr(_Tp* __px) { this->__set(__px); }



  template<class _Tp1> auto_ptr(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    this->__set(__conversionCheck);
  }

  template<class _Tp1> auto_ptr<_Tp>& operator=(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    reset(__conversionCheck);
    return *this;
  }


  auto_ptr(_Self& __r) { this->__set(__r.release()); }

  _Self& operator=(_Self& __r) {
    reset(__r.release());
    return *this;
  }

  ~auto_ptr() { delete this->get(); }

  auto_ptr(auto_ptr_ref<_Tp> __r) {
    this->__set(__r.release());
  }

  _Self& operator=(auto_ptr_ref<_Tp> __r) {
    reset(__r.release());
    return *this;
  }


  template<class _Tp1> operator auto_ptr_ref<_Tp1>() {
    return auto_ptr_ref<_Tp1>(*this, this->get());
  }
  template<class _Tp1> operator auto_ptr<_Tp1>() {
    return auto_ptr<_Tp1>(release());
  }





};
}
# 44 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2
# 61 "c:/marmalade/6.3/s3e/h/std/c++/memory"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 2
# 62 "c:/marmalade/6.3/s3e/h/std/c++/memory" 2
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h" 2

class b2Fixture;
class b2Joint;
class b2Contact;
class b2Controller;
class b2World;
struct b2FixtureDef;
struct b2JointEdge;
struct b2ContactEdge;





enum b2BodyType
{
 b2_staticBody = 0,
 b2_kinematicBody,
 b2_dynamicBody



};



struct b2BodyDef
{

 b2BodyDef()
 {
  userData = __null;
  position.Set(0.0f, 0.0f);
  angle = 0.0f;
  linearVelocity.Set(0.0f, 0.0f);
  angularVelocity = 0.0f;
  linearDamping = 0.0f;
  angularDamping = 0.0f;
  allowSleep = true;
  awake = true;
  fixedRotation = false;
  bullet = false;
  type = b2_staticBody;
  active = true;
  gravityScale = 1.0f;
 }



 b2BodyType type;



 b2Vec2 position;


 float32 angle;


 b2Vec2 linearVelocity;


 float32 angularVelocity;




 float32 linearDamping;




 float32 angularDamping;



 bool allowSleep;


 bool awake;


 bool fixedRotation;





 bool bullet;


 bool active;


 void* userData;


 float32 gravityScale;
};


class b2Body
{
public:







 b2Fixture* CreateFixture(const b2FixtureDef* def);
# 145 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h"
 b2Fixture* CreateFixture(const b2Shape* shape, float32 density);
# 154 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h"
 void DestroyFixture(b2Fixture* fixture);






 void SetTransform(const b2Vec2& position, float32 angle);



 const b2Transform& GetTransform() const;



 const b2Vec2& GetPosition() const;



 float32 GetAngle() const;


 const b2Vec2& GetWorldCenter() const;


 const b2Vec2& GetLocalCenter() const;



 void SetLinearVelocity(const b2Vec2& v);



 const b2Vec2& GetLinearVelocity() const;



 void SetAngularVelocity(float32 omega);



 float32 GetAngularVelocity() const;







 void ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake);




 void ApplyForceToCenter(const b2Vec2& force, bool wake);






 void ApplyTorque(float32 torque, bool wake);







 void ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake);




 void ApplyAngularImpulse(float32 impulse, bool wake);



 float32 GetMass() const;



 float32 GetInertia() const;



 void GetMassData(b2MassData* data) const;






 void SetMassData(const b2MassData* data);




 void ResetMassData();




 b2Vec2 GetWorldPoint(const b2Vec2& localPoint) const;




 b2Vec2 GetWorldVector(const b2Vec2& localVector) const;




 b2Vec2 GetLocalPoint(const b2Vec2& worldPoint) const;




 b2Vec2 GetLocalVector(const b2Vec2& worldVector) const;




 b2Vec2 GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const;




 b2Vec2 GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const;


 float32 GetLinearDamping() const;


 void SetLinearDamping(float32 linearDamping);


 float32 GetAngularDamping() const;


 void SetAngularDamping(float32 angularDamping);


 float32 GetGravityScale() const;


 void SetGravityScale(float32 scale);


 void SetType(b2BodyType type);


 b2BodyType GetType() const;


 void SetBullet(bool flag);


 bool IsBullet() const;



 void SetSleepingAllowed(bool flag);


 bool IsSleepingAllowed() const;




 void SetAwake(bool flag);



 bool IsAwake() const;
# 343 "v:/gigglingbits/box2d/Box2D/Dynamics/b2Body.h"
 void SetActive(bool flag);


 bool IsActive() const;



 void SetFixedRotation(bool flag);


 bool IsFixedRotation() const;


 b2Fixture* GetFixtureList();
 const b2Fixture* GetFixtureList() const;


 b2JointEdge* GetJointList();
 const b2JointEdge* GetJointList() const;




 b2ContactEdge* GetContactList();
 const b2ContactEdge* GetContactList() const;


 b2Body* GetNext();
 const b2Body* GetNext() const;


 void* GetUserData() const;


 void SetUserData(void* data);


 b2World* GetWorld();
 const b2World* GetWorld() const;


 void Dump();

private:

 friend class b2World;
 friend class b2Island;
 friend class b2ContactManager;
 friend class b2ContactSolver;
 friend class b2Contact;

 friend class b2DistanceJoint;
 friend class b2FrictionJoint;
 friend class b2GearJoint;
 friend class b2MotorJoint;
 friend class b2MouseJoint;
 friend class b2PrismaticJoint;
 friend class b2PulleyJoint;
 friend class b2RevoluteJoint;
 friend class b2RopeJoint;
 friend class b2WeldJoint;
 friend class b2WheelJoint;


 enum
 {
  e_islandFlag = 0x0001,
  e_awakeFlag = 0x0002,
  e_autoSleepFlag = 0x0004,
  e_bulletFlag = 0x0008,
  e_fixedRotationFlag = 0x0010,
  e_activeFlag = 0x0020,
  e_toiFlag = 0x0040
 };

 b2Body(const b2BodyDef* bd, b2World* world);
 ~b2Body();

 void SynchronizeFixtures();
 void SynchronizeTransform();



 bool ShouldCollide(const b2Body* other) const;

 void Advance(float32 t);

 b2BodyType m_type;

 uint16 m_flags;

 int32 m_islandIndex;

 b2Transform m_xf;
 b2Sweep m_sweep;

 b2Vec2 m_linearVelocity;
 float32 m_angularVelocity;

 b2Vec2 m_force;
 float32 m_torque;

 b2World* m_world;
 b2Body* m_prev;
 b2Body* m_next;

 b2Fixture* m_fixtureList;
 int32 m_fixtureCount;

 b2JointEdge* m_jointList;
 b2ContactEdge* m_contactList;

 float32 m_mass, m_invMass;


 float32 m_I, m_invI;

 float32 m_linearDamping;
 float32 m_angularDamping;
 float32 m_gravityScale;

 float32 m_sleepTime;

 void* m_userData;
};

inline b2BodyType b2Body::GetType() const
{
 return m_type;
}

inline const b2Transform& b2Body::GetTransform() const
{
 return m_xf;
}

inline const b2Vec2& b2Body::GetPosition() const
{
 return m_xf.p;
}

inline float32 b2Body::GetAngle() const
{
 return m_sweep.a;
}

inline const b2Vec2& b2Body::GetWorldCenter() const
{
 return m_sweep.c;
}

inline const b2Vec2& b2Body::GetLocalCenter() const
{
 return m_sweep.localCenter;
}

inline void b2Body::SetLinearVelocity(const b2Vec2& v)
{
 if (m_type == b2_staticBody)
 {
  return;
 }

 if (b2Dot(v,v) > 0.0f)
 {
  SetAwake(true);
 }

 m_linearVelocity = v;
}

inline const b2Vec2& b2Body::GetLinearVelocity() const
{
 return m_linearVelocity;
}

inline void b2Body::SetAngularVelocity(float32 w)
{
 if (m_type == b2_staticBody)
 {
  return;
 }

 if (w * w > 0.0f)
 {
  SetAwake(true);
 }

 m_angularVelocity = w;
}

inline float32 b2Body::GetAngularVelocity() const
{
 return m_angularVelocity;
}

inline float32 b2Body::GetMass() const
{
 return m_mass;
}

inline float32 b2Body::GetInertia() const
{
 return m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
}

inline void b2Body::GetMassData(b2MassData* data) const
{
 data->mass = m_mass;
 data->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
 data->center = m_sweep.localCenter;
}

inline b2Vec2 b2Body::GetWorldPoint(const b2Vec2& localPoint) const
{
 return b2Mul(m_xf, localPoint);
}

inline b2Vec2 b2Body::GetWorldVector(const b2Vec2& localVector) const
{
 return b2Mul(m_xf.q, localVector);
}

inline b2Vec2 b2Body::GetLocalPoint(const b2Vec2& worldPoint) const
{
 return b2MulT(m_xf, worldPoint);
}

inline b2Vec2 b2Body::GetLocalVector(const b2Vec2& worldVector) const
{
 return b2MulT(m_xf.q, worldVector);
}

inline b2Vec2 b2Body::GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const
{
 return m_linearVelocity + b2Cross(m_angularVelocity, worldPoint - m_sweep.c);
}

inline b2Vec2 b2Body::GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const
{
 return GetLinearVelocityFromWorldPoint(GetWorldPoint(localPoint));
}

inline float32 b2Body::GetLinearDamping() const
{
 return m_linearDamping;
}

inline void b2Body::SetLinearDamping(float32 linearDamping)
{
 m_linearDamping = linearDamping;
}

inline float32 b2Body::GetAngularDamping() const
{
 return m_angularDamping;
}

inline void b2Body::SetAngularDamping(float32 angularDamping)
{
 m_angularDamping = angularDamping;
}

inline float32 b2Body::GetGravityScale() const
{
 return m_gravityScale;
}

inline void b2Body::SetGravityScale(float32 scale)
{
 m_gravityScale = scale;
}

inline void b2Body::SetBullet(bool flag)
{
 if (flag)
 {
  m_flags |= e_bulletFlag;
 }
 else
 {
  m_flags &= ~e_bulletFlag;
 }
}

inline bool b2Body::IsBullet() const
{
 return (m_flags & e_bulletFlag) == e_bulletFlag;
}

inline void b2Body::SetAwake(bool flag)
{
 if (flag)
 {
  if ((m_flags & e_awakeFlag) == 0)
  {
   m_flags |= e_awakeFlag;
   m_sleepTime = 0.0f;
  }
 }
 else
 {
  m_flags &= ~e_awakeFlag;
  m_sleepTime = 0.0f;
  m_linearVelocity.SetZero();
  m_angularVelocity = 0.0f;
  m_force.SetZero();
  m_torque = 0.0f;
 }
}

inline bool b2Body::IsAwake() const
{
 return (m_flags & e_awakeFlag) == e_awakeFlag;
}

inline bool b2Body::IsActive() const
{
 return (m_flags & e_activeFlag) == e_activeFlag;
}

inline bool b2Body::IsFixedRotation() const
{
 return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
}

inline void b2Body::SetSleepingAllowed(bool flag)
{
 if (flag)
 {
  m_flags |= e_autoSleepFlag;
 }
 else
 {
  m_flags &= ~e_autoSleepFlag;
  SetAwake(true);
 }
}

inline bool b2Body::IsSleepingAllowed() const
{
 return (m_flags & e_autoSleepFlag) == e_autoSleepFlag;
}

inline b2Fixture* b2Body::GetFixtureList()
{
 return m_fixtureList;
}

inline const b2Fixture* b2Body::GetFixtureList() const
{
 return m_fixtureList;
}

inline b2JointEdge* b2Body::GetJointList()
{
 return m_jointList;
}

inline const b2JointEdge* b2Body::GetJointList() const
{
 return m_jointList;
}

inline b2ContactEdge* b2Body::GetContactList()
{
 return m_contactList;
}

inline const b2ContactEdge* b2Body::GetContactList() const
{
 return m_contactList;
}

inline b2Body* b2Body::GetNext()
{
 return m_next;
}

inline const b2Body* b2Body::GetNext() const
{
 return m_next;
}

inline void b2Body::SetUserData(void* data)
{
 m_userData = data;
}

inline void* b2Body::GetUserData() const
{
 return m_userData;
}

inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_force += force;
  m_torque += b2Cross(point - m_sweep.c, force);
 }
}

inline void b2Body::ApplyForceToCenter(const b2Vec2& force, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_force += force;
 }
}

inline void b2Body::ApplyTorque(float32 torque, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_torque += torque;
 }
}

inline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_linearVelocity += m_invMass * impulse;
  m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
 }
}

inline void b2Body::ApplyAngularImpulse(float32 impulse, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_angularVelocity += m_invI * impulse;
 }
}

inline void b2Body::SynchronizeTransform()
{
 m_xf.q.Set(m_sweep.a);
 m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
}

inline void b2Body::Advance(float32 alpha)
{

 m_sweep.Advance(alpha);
 m_sweep.c = m_sweep.c0;
 m_sweep.a = m_sweep.a0;
 m_xf.q.Set(m_sweep.a);
 m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
}

inline b2World* b2Body::GetWorld()
{
 return m_world;
}

inline const b2World* b2Body::GetWorld() const
{
 return m_world;
}
# 32 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2StackAllocator.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2StackAllocator.h"
const int32 b2_stackSize = 100 * 1024;
const int32 b2_maxStackEntries = 32;

struct b2StackEntry
{
 char* data;
 int32 size;
 bool usedMalloc;
};




class b2StackAllocator
{
public:
 b2StackAllocator();
 ~b2StackAllocator();

 void* Allocate(int32 size);
 void Free(void* p);

 int32 GetMaxAllocation() const;

private:

 char m_data[b2_stackSize];
 int32 m_index;

 int32 m_allocation;
 int32 m_maxAllocation;

 b2StackEntry m_entries[b2_maxStackEntries];
 int32 m_entryCount;
};
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/b2ContactManager.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Dynamics/b2ContactManager.h"
# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2BroadPhase.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2BroadPhase.h"
# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h" 1
# 23 "v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2GrowableStack.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Common/b2GrowableStack.h"
# 1 "c:/marmalade/6.3/s3e/h/std/memory.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/memory.h"
# 1 "c:/marmalade/6.3/s3e/h/std/string.h" 1
# 16 "c:/marmalade/6.3/s3e/h/std/memory.h" 2
# 23 "v:/gigglingbits/box2d/Box2D/Common/b2GrowableStack.h" 2




template <typename T, int32 N>
class b2GrowableStack
{
public:
 b2GrowableStack()
 {
  m_stack = m_array;
  m_count = 0;
  m_capacity = N;
 }

 ~b2GrowableStack()
 {
  if (m_stack != m_array)
  {
   b2Free(m_stack);
   m_stack = __null;
  }
 }

 void Push(const T& element)
 {
  if (m_count == m_capacity)
  {
   T* old = m_stack;
   m_capacity *= 2;
   m_stack = (T*)b2Alloc(m_capacity * sizeof(T));
   memcpy(m_stack, old, m_count * sizeof(T));
   if (old != m_array)
   {
    b2Free(old);
   }
  }

  m_stack[m_count] = element;
  ++m_count;
 }

 T Pop()
 {
  ((m_count > 0) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Common/b2GrowableStack.h", 67, "m_count > 0"));
  --m_count;
  return m_stack[m_count];
 }

 int32 GetCount()
 {
  return m_count;
 }

private:
 T* m_stack;
 T m_array[N];
 int32 m_count;
 int32 m_capacity;
};
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h" 2




struct b2TreeNode
{
 bool IsLeaf() const
 {
  return child1 == (-1);
 }


 b2AABB aabb;

 void* userData;

 union
 {
  int32 parent;
  int32 next;
 };

 int32 child1;
 int32 child2;


 int32 height;
};
# 61 "v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h"
class b2DynamicTree
{
public:

 b2DynamicTree();


 ~b2DynamicTree();


 int32 CreateProxy(const b2AABB& aabb, void* userData);


 void DestroyProxy(int32 proxyId);





 bool MoveProxy(int32 proxyId, const b2AABB& aabb1, const b2Vec2& displacement);



 void* GetUserData(int32 proxyId) const;


 const b2AABB& GetFatAABB(int32 proxyId) const;



 template <typename T>
 void Query(T* callback, const b2AABB& aabb) const;
# 101 "v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h"
 template <typename T>
 void RayCast(T* callback, const b2RayCastInput& input) const;


 void Validate() const;



 int32 GetHeight() const;



 int32 GetMaxBalance() const;


 float32 GetAreaRatio() const;


 void RebuildBottomUp();




 void ShiftOrigin(const b2Vec2& newOrigin);

private:

 int32 AllocateNode();
 void FreeNode(int32 node);

 void InsertLeaf(int32 node);
 void RemoveLeaf(int32 node);

 int32 Balance(int32 index);

 int32 ComputeHeight() const;
 int32 ComputeHeight(int32 nodeId) const;

 void ValidateStructure(int32 index) const;
 void ValidateMetrics(int32 index) const;

 int32 m_root;

 b2TreeNode* m_nodes;
 int32 m_nodeCount;
 int32 m_nodeCapacity;

 int32 m_freeList;


 uint32 m_path;

 int32 m_insertionCount;
};

inline void* b2DynamicTree::GetUserData(int32 proxyId) const
{
 ((0 <= proxyId && proxyId < m_nodeCapacity) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h", 158, "0 <= proxyId && proxyId < m_nodeCapacity"));
 return m_nodes[proxyId].userData;
}

inline const b2AABB& b2DynamicTree::GetFatAABB(int32 proxyId) const
{
 ((0 <= proxyId && proxyId < m_nodeCapacity) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h", 164, "0 <= proxyId && proxyId < m_nodeCapacity"));
 return m_nodes[proxyId].aabb;
}

template <typename T>
inline void b2DynamicTree::Query(T* callback, const b2AABB& aabb) const
{
 b2GrowableStack<int32, 256> stack;
 stack.Push(m_root);

 while (stack.GetCount() > 0)
 {
  int32 nodeId = stack.Pop();
  if (nodeId == (-1))
  {
   continue;
  }

  const b2TreeNode* node = m_nodes + nodeId;

  if (b2TestOverlap(node->aabb, aabb))
  {
   if (node->IsLeaf())
   {
    bool proceed = callback->QueryCallback(nodeId);
    if (proceed == false)
    {
     return;
    }
   }
   else
   {
    stack.Push(node->child1);
    stack.Push(node->child2);
   }
  }
 }
}

template <typename T>
inline void b2DynamicTree::RayCast(T* callback, const b2RayCastInput& input) const
{
 b2Vec2 p1 = input.p1;
 b2Vec2 p2 = input.p2;
 b2Vec2 r = p2 - p1;
 ((r.LengthSquared() > 0.0f) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2DynamicTree.h", 209, "r.LengthSquared() > 0.0f"));
 r.Normalize();


 b2Vec2 v = b2Cross(1.0f, r);
 b2Vec2 abs_v = b2Abs(v);




 float32 maxFraction = input.maxFraction;


 b2AABB segmentAABB;
 {
  b2Vec2 t = p1 + maxFraction * (p2 - p1);
  segmentAABB.lowerBound = b2Min(p1, t);
  segmentAABB.upperBound = b2Max(p1, t);
 }

 b2GrowableStack<int32, 256> stack;
 stack.Push(m_root);

 while (stack.GetCount() > 0)
 {
  int32 nodeId = stack.Pop();
  if (nodeId == (-1))
  {
   continue;
  }

  const b2TreeNode* node = m_nodes + nodeId;

  if (b2TestOverlap(node->aabb, segmentAABB) == false)
  {
   continue;
  }



  b2Vec2 c = node->aabb.GetCenter();
  b2Vec2 h = node->aabb.GetExtents();
  float32 separation = b2Abs(b2Dot(v, p1 - c)) - b2Dot(abs_v, h);
  if (separation > 0.0f)
  {
   continue;
  }

  if (node->IsLeaf())
  {
   b2RayCastInput subInput;
   subInput.p1 = input.p1;
   subInput.p2 = input.p2;
   subInput.maxFraction = maxFraction;

   float32 value = callback->RayCastCallback(subInput, nodeId);

   if (value == 0.0f)
   {

    return;
   }

   if (value > 0.0f)
   {

    maxFraction = value;
    b2Vec2 t = p1 + maxFraction * (p2 - p1);
    segmentAABB.lowerBound = b2Min(p1, t);
    segmentAABB.upperBound = b2Max(p1, t);
   }
  }
  else
  {
   stack.Push(node->child1);
   stack.Push(node->child2);
  }
 }
}
# 25 "v:/gigglingbits/box2d/Box2D/Collision/b2BroadPhase.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/c++/algorithm" 1
# 31 "c:/marmalade/6.3/s3e/h/std/c++/algorithm"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.3/s3e/h/std/c++/stl/_prolog.h" 2
# 32 "c:/marmalade/6.3/s3e/h/std/c++/algorithm" 2



        
# 44 "c:/marmalade/6.3/s3e/h/std/c++/algorithm"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h" 1
# 42 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_heap.h" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/stl/_heap.h"
namespace _STL {



template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);


template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp);

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val);

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __val);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
       _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp);

template <class _RandomAccessIterator, class _Tp, class _Compare,
          class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Compare __comp,
           _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                __val, __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
inline
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--);
}

template <class _RandomAccessIterator, class _Compare>
inline
void
sort_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--, __comp);
}

}


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_heap.c" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/stl/_heap.c"
namespace _STL {

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline
void
__push_heap(_RandomAccessIterator __first,
            _Distance __holeIndex, _Distance __topIndex, _Tp __val)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && *(__first + __parent) < __val) {
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)));
}

template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __push_heap_aux(__first, __last,
                  (typename iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename iterator_traits< _RandomAccessIterator >::value_type*)0);
}


template <class _RandomAccessIterator, class _Distance, class _Tp,
          class _Compare>
inline
void
__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
            _Distance __topIndex, _Tp __val, _Compare __comp)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __val)) {
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Compare,
          class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Compare __comp,
                _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)), __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp)
{
  __push_heap_aux(__first, __last, __comp,
                  (typename iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val) {
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
      __secondChild--;
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val);
}


template <class _RandomAccessIterator, class _Tp>
inline void
__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
  __pop_heap(__first, __last - 1, __last - 1,
             _Tp(*(__last - 1)), (typename iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
       _RandomAccessIterator __last) {
  __pop_heap_aux(__first, __last, (typename iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp)
{
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
      __secondChild--;
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val, __comp);
}


template <class _RandomAccessIterator, class _Tp, class _Compare>
inline void
__pop_heap_aux(_RandomAccessIterator __first,
               _RandomAccessIterator __last, _Tp*, _Compare __comp)
{
  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,
             (typename iterator_traits< _RandomAccessIterator >::difference_type*)0);
}


template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp)
{
    __pop_heap_aux(__first, __last, (typename iterator_traits< _RandomAccessIterator >::value_type*)0, __comp);
}

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first,
            _RandomAccessIterator __last, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  while (true) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __make_heap(__first, __last,
              (typename iterator_traits< _RandomAccessIterator >::value_type*)0, (typename iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator, class _Compare,
          class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  while (true) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),
                  __comp);
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  __make_heap(__first, __last, __comp,
              (typename iterator_traits< _RandomAccessIterator >::value_type*)0, (typename iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

}
# 123 "c:/marmalade/6.3/s3e/h/std/c++/stl/_heap.h" 2
# 43 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h" 2







# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_function_base.h" 1
# 37 "c:/marmalade/6.3/s3e/h/std/c++/stl/_function_base.h"
namespace _STL {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 188 "c:/marmalade/6.3/s3e/h/std/c++/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}
# 51 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h" 2







namespace _STL {


template <class _InputIter, class _Function>
inline _Function
for_each(_InputIter __first, _InputIter __last, _Function __f) {
  for ( ; __first != __last; ++__first)
    __f(*__first);
  return __f;
}


template <class _InputIter, class _Predicate>
inline typename iterator_traits<_InputIter>::difference_type
count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {
 
typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      ++__n;
  return __n;
}



template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last,
              _BinaryPredicate __binary_pred) {
 
  if (__first == __last)
    return __last;
  _ForwardIter __next = __first;
  while(++__next != __last) {
    if (__binary_pred(*__first, *__next))
      return __first;
    __first = __next;
  }
  return __last;
}

template <class _ForwardIter>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last) {
  return adjacent_find(__first, __last,
         __equal_to((typename iterator_traits< _ForwardIter >::value_type*)0));
}


template <class _InputIter, class _Tp, class _Size>
inline void
count(_InputIter __first, _InputIter __last, const _Tp& __val, _Size& __n) {
 
    for ( ; __first != __last; ++__first)
      if (*__first == __val)
        ++__n;
}

template <class _InputIter, class _Predicate, class _Size>
inline void
count_if(_InputIter __first, _InputIter __last, _Predicate __pred, _Size& __n) {
 
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      ++__n;
}


template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val);
template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val, _BinaryPred __binary_pred);

template <class _InputIter, class _ForwardIter>
inline _InputIter find_first_of(_InputIter __first1, _InputIter __last1,
                                _ForwardIter __first2, _ForwardIter __last2) {
 
 
  return __find_first_of(__first1, __last1, __first2, __last2,__equal_to((typename iterator_traits< _InputIter >::value_type*)0));
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _InputIter
find_first_of(_InputIter __first1, _InputIter __last1,
              _ForwardIter __first2, _ForwardIter __last2,_BinaryPredicate __comp) {
 
 
  return __find_first_of(__first1, __last1, __first2, __last2,__comp);
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter1, class _ForwardIter2>
inline _ForwardIter2
swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2) {
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    iter_swap(__first1, __first2);
  return __first2;
}


template <class _InputIter, class _OutputIter, class _UnaryOperation>
inline _OutputIter
transform(_InputIter __first, _InputIter __last, _OutputIter __result, _UnaryOperation __opr) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __opr(*__first);
  return __result;
}
template <class _InputIter1, class _InputIter2, class _OutputIter, class _BinaryOperation>
inline _OutputIter
transform(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _OutputIter __result,_BinaryOperation __binary_op) {
 
  for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}



template <class _ForwardIter, class _Predicate, class _Tp>
inline void
replace_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}

template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
replace_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
             const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = *__first == __old_value ? __new_value : *__first;
  return __result;
}

template <class _Iterator, class _OutputIter, class _Predicate, class _Tp>
inline _OutputIter
replace_copy_if(_Iterator __first, _Iterator __last,
                _OutputIter __result,
                _Predicate __pred, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __pred(*__first) ? __new_value : *__first;
  return __result;
}



template <class _ForwardIter, class _Generator>
inline void
generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {
 
  for ( ; __first != __last; ++__first)
    *__first = __gen();
}

template <class _OutputIter, class _Size, class _Generator>
inline _OutputIter
generate_n(_OutputIter __first, _Size __n, _Generator __gen) {
  for ( ; __n > 0; --__n, ++__first)
    *__first = __gen();
  return __first;
}



template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
remove_copy(_InputIter __first, _InputIter __last,_OutputIter __result, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    if (!(*__first == __val)) {
      *__result = *__first;
      ++__result;
    }
  return __result;
}

template <class _InputIter, class _OutputIter, class _Predicate>
inline _OutputIter
remove_copy_if(_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred) {
 
  for ( ; __first != __last; ++__first)
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  return __result;
}

template <class _ForwardIter, class _Tp>
inline _ForwardIter
remove(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  __first = find(__first, __last, __val);
  if (__first == __last)
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy(++__next, __last, __first, __val);
  }
}

template <class _ForwardIter, class _Predicate>
inline _ForwardIter
remove_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  __first = find_if(__first, __last, __pred);
  if ( __first == __last )
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy_if(++__next, __last, __first, __pred);
  }
}


template <class _InputIter, class _OutputIter>
_OutputIter unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result);

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
                        _BinaryPredicate __binary_pred);

template <class _ForwardIter>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
  __first = adjacent_find(__first, __last);
  return unique_copy(__first, __last, __first);
}

template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,
                    _BinaryPredicate __binary_pred) {
  __first = adjacent_find(__first, __last, __binary_pred);
  return unique_copy(__first, __last, __first, __binary_pred);
}



template <class _BidirectionalIter>
inline void
__reverse(_BidirectionalIter __first, _BidirectionalIter __last, const bidirectional_iterator_tag &) {
  for(; __first != __last && __first != --__last; ++__first)
    iter_swap(__first,__last);
}


template <class _RandomAccessIter>
inline void
__reverse(_RandomAccessIter __first, _RandomAccessIter __last, const random_access_iterator_tag &) {
  for (; __first < __last; ++__first) iter_swap(__first, --__last);
}

template <class _BidirectionalIter>
inline void
reverse(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  __reverse(__first, __last, typename iterator_traits< _BidirectionalIter >::iterator_category());
}

template <class _BidirectionalIter, class _OutputIter>
inline
_OutputIter reverse_copy(_BidirectionalIter __first,
                            _BidirectionalIter __last,
                            _OutputIter __result) {
 
  while (__first != __last) {
    --__last;
    *__result = *__last;
    ++__result;
  }
  return __result;
}



template <class _EuclideanRingElement>
inline
_EuclideanRingElement __gcd(_EuclideanRingElement __m,
                            _EuclideanRingElement __n)
{
  while (__n != 0) {
    _EuclideanRingElement __t = __m % __n;
    __m = __n;
    __n = __t;
  }
  return __m;
}

template <class _ForwardIter>
_ForwardIter
rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last);

template <class _ForwardIter, class _OutputIter>
inline _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                               _ForwardIter __last, _OutputIter __result) {
  return copy(__first, __middle, copy(__middle, __last, __result));
}



template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator& __rand);




template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out, const _Distance __n);

template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out, const _Distance __n,
                            _RandomNumberGenerator& __rand);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last);

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand);





template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);


template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);



template <class _Size>
inline _Size __lg(_Size __n) {
  _Size __k;
  for (__k = 0; __n != 1; __n >>= 1) ++__k;
  return __k;
}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last);
template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp);


template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
   _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
   _RandomAccessIter __last, _Compare __comp);



template <class _RandomAccessIter>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle, _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
             _RandomAccessIter __last, _Compare __comp);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last);

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp);



template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp);


template <class _T1, class _T2>
struct __less_2 {
  bool operator() (const _T1& __x, const _T2 __y) const { return __x < __y ; }
};

template <class _T1, class _T2>
__less_2<_T1,_T2> __less2(_T1*, _T2* ) { return __less_2<_T1, _T2>(); }
# 491 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h"
template <class _ForwardIter, class _Tp>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                   const _Tp& __val) {
 
    return __lower_bound(__first, __last, __val,
    __less2((typename iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
    (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
 
  return __lower_bound(__first, __last, __val, __comp, (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
                           const _Tp& __val, _Compare __comp, _Distance*);

template <class _ForwardIter, class _Tp>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val) {
 
  return __upper_bound(__first, __last, __val,
         __less2((typename iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                       (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
 
  return __upper_bound(__first, __last, __val, __comp,
                       (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare __comp, _Distance*);

template <class _ForwardIter, class _Tp>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  return __equal_range(__first, __last, __val,
         __less2((typename iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                       (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
            _Compare __comp) {
 
  return __equal_range(__first, __last, __val, __comp,
                       (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                   const _Tp& __val) {
 
  _ForwardIter __i = __lower_bound(__first, __last, __val,
                                   __less2((typename iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                   (typename iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !(__val < *__i);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                   const _Tp& __val,
                   _Compare __comp) {
 
  _ForwardIter __i = __lower_bound(__first, __last, __val, __comp, (typename iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !__comp(__val, *__i);
}



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp);





template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
     _BidirectionalIter __middle,
     _BidirectionalIter __last) ;

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
     _BidirectionalIter __middle,
     _BidirectionalIter __last, _Compare __comp);






template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp);



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result);


template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp);





template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last);
template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last);

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);




template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last);

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);


template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last);


template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);







template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
      _StrictWeakOrdering __comp);





template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp);

template <class _ForwardIter>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last) {
  return __is_sorted(__first, __last, __less((typename iterator_traits< _ForwardIter >::value_type*)0));
}

template <class _ForwardIter, class _StrictWeakOrdering>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last,
                      _StrictWeakOrdering __comp) {
  return __is_sorted(__first, __last, __comp);
}


}


# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.c" 1
# 33 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.c"
namespace _STL {

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp);


template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp);

template <class _Tp>

inline

const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {
  if (__a < __b)
    if (__b < __c)
      return __b;
    else if (__a < __c)
      return __c;
    else
      return __a;
  else if (__a < __c)
    return __a;
  else if (__b < __c)
    return __c;
  else
    return __b;
}

template <class _Tp, class _Compare>

inline

const _Tp&
__median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {
  if (__comp(__a, __b))
    if (__comp(__b, __c))
      return __b;
    else if (__comp(__a, __c))
      return __c;
    else
      return __a;
  else if (__comp(__a, __c))
    return __a;
  else if (__comp(__b, __c))
    return __c;
  else
    return __b;
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2)
{
 
 

  if (__first1 == __last1 || __first2 == __last2)
    return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2)
    return find(__first1, __last1, *__first2);


  _ForwardIter2 __p1 = __first2;
  ++__p1;

  _ForwardIter1 __current = __first1;

  while (__first1 != __last1) {
    __first1 = find(__first1, __last1, *__first2);
    if (__first1 == __last1)
      return __last1;

    _ForwardIter2 __p = __p1;
    __current = __first1;
    if (++__current == __last1)
      return __last1;

    while (*__current == *__p) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val) {
 
  if (__count <= 0)
    return __first;
  else {
    __first = find(__first, __last, __val);
    while (__first != __last) {
      _Integer __n = __count - 1;
      _ForwardIter __i = __first;
      ++__i;
      while (__i != __last && __n != 0 && *__i == __val) {
        ++__i;
        --__n;
      }
      if (__n == 0)
        return __first;
      else
        __first = find(__i, __last, __val);
    }
    return __last;
  }
}

template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val,
                      _BinaryPred __binary_pred) {
 
  if (__count <= 0)
    return __first;
  else {
    while (__first != __last) {
      if (__binary_pred(*__first, __val))
        break;
      ++__first;
    }
    while (__first != __last) {
      _Integer __n = __count - 1;
      _ForwardIter __i = __first;
      ++__i;
      while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
        ++__i;
        --__n;
      }
      if (__n == 0)
        return __first;
      else {
        while (__i != __last) {
          if (__binary_pred(*__i, __val))
            break;
          ++__i;
        }
        __first = __i;
      }
    }
    return __last;
  }
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2)
{
 
 
  return __find_end(__first1, __last1, __first2, __last2,

                    typename iterator_traits< _ForwardIter1 >::iterator_category(),
                    typename iterator_traits< _ForwardIter2 >::iterator_category(),




                    __equal_to((typename iterator_traits< _ForwardIter1 >::value_type*)0)
    );
}


template <class _InputIterator, class _OutputIterator, class _BinaryPredicate,
         class _Tp>
inline _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last,
              _OutputIterator __result,
              _BinaryPredicate __binary_pred, _Tp*) {
  _Tp __val = *__first;
  *__result = __val;
  while (++__first != __last)
    if (!__binary_pred(__val, *__first)) {
      __val = *__first;
      *++__result = __val;
    }
  return ++__result;
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
inline _OutputIter
__unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
              _BinaryPredicate __binary_pred, const output_iterator_tag &) {
  return __unique_copy(__first, __last, __result, __binary_pred, (typename iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
__unique_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
              _BinaryPredicate __binary_pred, const forward_iterator_tag &) {
  *__result = *__first;
  while (++__first != __last)
    if (!__binary_pred(*__result, *__first)) *++__result = *__first;
  return ++__result;
}
# 272 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.c"
template <class _InputIter, class _OutputIter>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
  if (__first == __last) return __result;
  return __unique_copy(__first, __last, __result, __equal_to((typename iterator_traits< _InputIter >::value_type*)0),
                       typename iterator_traits< _OutputIter >::iterator_category());
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
            _BinaryPredicate __binary_pred) {
 
  if (__first == __last) return __result;
  return __unique_copy(__first, __last, __result, __binary_pred,
                       typename iterator_traits< _OutputIter >::iterator_category());
}



template <class _ForwardIter, class _Distance>
_ForwardIter __rotate(_ForwardIter __first,
                      _ForwardIter __middle,
                      _ForwardIter __last,
                      _Distance*,
                      const forward_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last == __middle)
    return __first;

  _ForwardIter __first2 = __middle;
  do {
    swap(*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
  } while (__first2 != __last);

  _ForwardIter __new_middle = __first;

  __first2 = __middle;

  while (__first2 != __last) {
    swap (*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
    else if (__first2 == __last)
      __first2 = __middle;
  }

  return __new_middle;
}

template <class _BidirectionalIter, class _Distance>
_BidirectionalIter __rotate(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance*,
                            const bidirectional_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last == __middle)
    return __first;

  __reverse(__first, __middle, bidirectional_iterator_tag());
  __reverse(__middle, __last, bidirectional_iterator_tag());

  while (__first != __middle && __middle != __last)
    swap (*__first++, *--__last);

  if (__first == __middle) {
    __reverse(__middle, __last, bidirectional_iterator_tag());
    return __last;
  }
  else {
    __reverse(__first, __middle, bidirectional_iterator_tag());
    return __first;
  }
}

template <class _RandomAccessIter, class _Distance, class _Tp>
_RandomAccessIter __rotate(_RandomAccessIter __first,
                           _RandomAccessIter __middle,
                           _RandomAccessIter __last,
                           _Distance *, _Tp *) {

  _Distance __n = __last - __first;
  _Distance __k = __middle - __first;
  _Distance __l = __n - __k;
  _RandomAccessIter __result = __first + (__last - __middle);

  if (__k==0)
    return __last;

  if (__k == __l) {
    swap_ranges(__first, __middle, __middle);
    return __result;
  }

  _Distance __d = __gcd(__n, __k);

  for (_Distance __i = 0; __i < __d; __i++) {
    _Tp __tmp = *__first;
    _RandomAccessIter __p = __first;

    if (__k < __l) {
      for (_Distance __j = 0; __j < __l/__d; __j++) {
 if (__p > __first + __l) {
          *__p = *(__p - __l);
          __p -= __l;
        }

        *__p = *(__p + __k);
        __p += __k;
      }
    }

    else {
      for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
        if (__p < __last - __k) {
          *__p = *(__p + __k);
          __p += __k;
        }

        *__p = * (__p - __l);
        __p -= __l;
      }
    }

    *__p = __tmp;
    ++__first;
  }

  return __result;
}

template <class _RandomAccessIter, class _Distance>
inline _RandomAccessIter
__rotate(_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last,
         _Distance * __dis, const random_access_iterator_tag &) {
  return __rotate(__first, __middle, __last,
                  __dis, (typename iterator_traits< _RandomAccessIter >::value_type*)0);
}

template <class _ForwardIter>
_ForwardIter
rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {
 
 
  return __rotate(__first, __middle, __last,
                  (typename iterator_traits< _ForwardIter >::difference_type*)0,
                  typename iterator_traits< _ForwardIter >::iterator_category());
}





template <class _Distance>
inline _Distance __random_number(_Distance __n) {

  return rand() % __n;



}

template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first,
      _RandomAccessIter __last) {
 
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + __random_number((__i - __first) + 1));
}

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator& __rand) {
 
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + __rand((__i - __first) + 1));
}





template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out, const _Distance __n)
{
 
  _Distance __remaining = distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (__random_number(__remaining) < __m) {
      *__out = *__first;
      ++__out;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out;
}


template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out, const _Distance __n,
                            _RandomNumberGenerator& __rand)
{
 
  _Distance __remaining = distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (__rand(__remaining) < __m) {
      *__out = *__first;
      ++__out;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out;
}

template <class _InputIter, class _RandomAccessIter, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out,
                                  const _Distance __n)
{
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __random_number(__t);
    if (__M < __n)
      __out[__M] = *__first;
    ++__first;
  }

  return __out + __m;
}

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out,
                                  _RandomNumberGenerator& __rand,
                                  const _Distance __n)
{
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __rand(__t);
    if (__M < __n)
      __out[__M] = *__first;
    ++__first;
  }

  return __out + __m;
}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last)
{
 
 
  return __random_sample(__first, __last,
                         __out_first, __out_last - __out_first);
}

template <class _InputIter, class _RandomAccessIter, class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand)
{
 
 
  return __random_sample(__first, __last,
                         __out_first, __rand,
                         __out_last - __out_first);
}





template <class _ForwardIter, class _Predicate>
inline _ForwardIter __partition(_ForwardIter __first,
                                           _ForwardIter __last,
                                           _Predicate __pred,
                                           const forward_iterator_tag &) {
  if (__first == __last) return __first;

  while (__pred(*__first))
    if (++__first == __last) return __first;

  _ForwardIter __next = __first;

  while (++__next != __last)
    if (__pred(*__next)) {
      swap(*__first, *__next);
      ++__first;
    }
  return __first;
}

template <class _BidirectionalIter, class _Predicate>
inline _BidirectionalIter __partition(_BidirectionalIter __first,
                                                 _BidirectionalIter __last,
                                                 _Predicate __pred,
                                                 const bidirectional_iterator_tag &) {
  while (true) {
    while (true)
      if (__first == __last)
        return __first;
      else if (__pred(*__first))
        ++__first;
      else
        break;
    --__last;
    while (true)
      if (__first == __last)
        return __first;
      else if (!__pred(*__last))
        --__last;
      else
        break;
    iter_swap(__first, __last);
    ++__first;
  }
}
# 636 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.c"
template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  return __partition(__first, __last, __pred, typename iterator_traits< _ForwardIter >::iterator_category());
}


template <class _ForwardIter, class _Predicate, class _Distance>
_ForwardIter __inplace_stable_partition(_ForwardIter __first,
                                        _ForwardIter __last,
                                        _Predicate __pred, _Distance __len) {
  if (__len == 1)
    return __pred(*__first) ? __last : __first;
  _ForwardIter __middle = __first;
  advance(__middle, __len / 2);
  return rotate(__inplace_stable_partition(__first, __middle, __pred,
                                           __len / 2),
                __middle,
                __inplace_stable_partition(__middle, __last, __pred,
                                           __len - __len / 2));
}

template <class _ForwardIter, class _Pointer, class _Predicate,
          class _Distance>
_ForwardIter __stable_partition_adaptive(_ForwardIter __first,
                                         _ForwardIter __last,
                                         _Predicate __pred, _Distance __len,
                                         _Pointer __buffer,
                                         _Distance __buffer_size)
{
  if (__len <= __buffer_size) {
    _ForwardIter __result1 = __first;
    _Pointer __result2 = __buffer;
    for ( ; __first != __last ; ++__first)
      if (__pred(*__first)) {
        *__result1 = *__first;
        ++__result1;
      }
      else {
        *__result2 = *__first;
        ++__result2;
      }
    copy(__buffer, __result2, __result1);
    return __result1;
  }
  else {
    _ForwardIter __middle = __first;
    advance(__middle, __len / 2);
    return rotate(__stable_partition_adaptive(
                          __first, __middle, __pred,
                          __len / 2, __buffer, __buffer_size),
                    __middle,
                    __stable_partition_adaptive(
                          __middle, __last, __pred,
                          __len - __len / 2, __buffer, __buffer_size));
  }
}

template <class _ForwardIter, class _Predicate, class _Tp, class _Distance>
inline _ForwardIter
__stable_partition_aux(_ForwardIter __first, _ForwardIter __last,
                       _Predicate __pred, _Tp*, _Distance*)
{
  _Temporary_buffer<_ForwardIter, _Tp> __buf(__first, __last);
 
  return (__buf.size() > 0) ?
    __stable_partition_adaptive(__first, __last, __pred,
    _Distance(__buf.requested_size()),
    __buf.begin(), __buf.size()) :
    __inplace_stable_partition(__first, __last, __pred,
          _Distance(__buf.requested_size()));
 
}

template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  if (__first == __last)
    return __first;
  else
    return __stable_partition_aux(__first, __last, __pred,
                                  (typename iterator_traits< _ForwardIter >::value_type*)0,
                                  (typename iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _RandomAccessIter, class _Tp, class _Compare>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first,
                                        _RandomAccessIter __last,
                                        _Tp __pivot, _Compare __comp)
{
  while (true) {
    while (__comp(*__first, __pivot))
      ++__first;
    --__last;
    while (__comp(__pivot, *__last))
      --__last;
    if (!(__first < __last))
      return __first;
    iter_swap(__first, __last);
    ++__first;
  }
}





template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val,
                               _Compare __comp) {
  _RandomAccessIter __next = __last;
  --__next;
  while (__comp(__val, *__next)) {
    *__last = *__next;
    __last = __next;
    --__next;
  }
  *__last = __val;
}

template <class _RandomAccessIter, class _Tp, class _Compare>
inline void __linear_insert(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Tp __val, _Compare __comp) {


  if (__comp(__val, *__first)) {
    copy_backward(__first, __last, __last + 1);
    *__first = __val;
  }
  else
    __unguarded_linear_insert(__last, __val, __comp);
}

template <class _RandomAccessIter, class _Compare>
void __insertion_sort(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Compare __comp) {
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    __linear_insert(__first, __i, *__i, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_insertion_sort_aux(_RandomAccessIter __first,
                                    _RandomAccessIter __last,
                                    _Tp*, _Compare __comp) {
  for (_RandomAccessIter __i = __first; __i != __last; ++__i)
    __unguarded_linear_insert(__i, _Tp(*__i), __comp);
}

template <class _RandomAccessIter, class _Compare>
inline void __unguarded_insertion_sort(_RandomAccessIter __first,
                                       _RandomAccessIter __last,
                                       _Compare __comp) {
  __unguarded_insertion_sort_aux(__first, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first > 16) {
    __insertion_sort(__first, __first + 16, __comp);
    __unguarded_insertion_sort(__first + 16, __last, __comp);
  }
  else
    __insertion_sort(__first, __last, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Size, class _Compare>
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit, _Compare __comp)
{
  while (__last - __first > 16) {
    if (__depth_limit == 0) {
      partial_sort(__first, __last, __last, __comp);
      return;
    }
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1), __comp)),
       __comp);
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit, __comp);
    __last = __cut;
  }
}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
 
  if (__first != __last) {
    __introsort_loop(__first, __last,
                     (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                     __lg(__last - __first) * 2, __less((typename iterator_traits< _RandomAccessIter >::value_type*)0) );
    __final_insertion_sort(__first, __last, __less((typename iterator_traits< _RandomAccessIter >::value_type*)0));
  }
}

template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp) {
 
  if (__first != __last) {
    __introsort_loop(__first, __last,
                     (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                     __lg(__last - __first) * 2,
                     __comp);
    __final_insertion_sort(__first, __last, __comp);
  }
}



template <class _RandomAccessIter, class _Compare>
void __inplace_stable_sort(_RandomAccessIter __first,
                           _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first < 15) {
    __insertion_sort(__first, __last, __comp);
    return;
  }
  _RandomAccessIter __middle = __first + (__last - __first) / 2;
  __inplace_stable_sort(__first, __middle, __comp);
  __inplace_stable_sort(__middle, __last, __comp);
  __merge_without_buffer(__first, __middle, __last,
                         __middle - __first,
                         __last - __middle,
                         __comp);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
          class _Distance, class _Compare>
void __merge_sort_loop(_RandomAccessIter1 __first,
                       _RandomAccessIter1 __last,
                       _RandomAccessIter2 __result, _Distance __step_size,
                       _Compare __comp) {
  _Distance __two_step = 2 * __step_size;

  while (__last - __first >= __two_step) {
    __result = merge(__first, __first + __step_size,
                     __first + __step_size, __first + __two_step,
                     __result,
                     __comp);
    __first += __two_step;
  }
  __step_size = (min) (_Distance(__last - __first), __step_size);

  merge(__first, __first + __step_size,
        __first + __step_size, __last,
        __result,
        __comp);
}

const int __stl_chunk_size = 7;

template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last,
                            _Distance __chunk_size, _Compare __comp)
{
  while (__last - __first >= __chunk_size) {
    __insertion_sort(__first, __first + __chunk_size, __comp);
    __first += __chunk_size;
  }
  __insertion_sort(__first, __last, __comp);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __merge_sort_with_buffer(_RandomAccessIter __first,
                              _RandomAccessIter __last, _Pointer __buffer,
                              _Distance*, _Compare __comp) {
  _Distance __len = __last - __first;
  _Pointer __buffer_last = __buffer + __len;

  _Distance __step_size = __stl_chunk_size;
  __chunk_insertion_sort(__first, __last, __step_size, __comp);

  while (__step_size < __len) {
    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
    __step_size *= 2;
    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
    __step_size *= 2;
  }
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
_BidirectionalIter1 __rotate_adaptive(_BidirectionalIter1 __first,
                                      _BidirectionalIter1 __middle,
                                      _BidirectionalIter1 __last,
                                      _Distance __len1, _Distance __len2,
                                      _BidirectionalIter2 __buffer,
                                      _Distance __buffer_size) {
  if (__len1 > __len2 && __len2 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = copy(__middle, __last, __buffer);
    copy_backward(__first, __middle, __last);
    return copy(__buffer, __buffer_end, __first);
  }
  else if (__len1 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = copy(__first, __middle, __buffer);
    copy(__middle, __last, __first);
    return copy_backward(__buffer, __buffer_end, __last);
  }
  else
    return rotate(__first, __middle, __last);
}

template <class _BidirectionalIter, class _Distance, class _Pointer,
          class _Compare>
void __merge_adaptive(_BidirectionalIter __first,
                      _BidirectionalIter __middle,
                      _BidirectionalIter __last,
                      _Distance __len1, _Distance __len2,
                      _Pointer __buffer, _Distance __buffer_size,
                      _Compare __comp) {
  if (__len1 <= __len2 && __len1 <= __buffer_size) {
    _Pointer __buffer_end = copy(__first, __middle, __buffer);
    merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
  }
  else if (__len2 <= __buffer_size) {
    _Pointer __buffer_end = copy(__middle, __last, __buffer);
    __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                     __comp);
  }
  else {
    _BidirectionalIter __first_cut = __first;
    _BidirectionalIter __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2) {
      __len11 = __len1 / 2;
      advance(__first_cut, __len11);
      __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
      __len22 += distance(__middle, __second_cut);
    }
    else {
      __len22 = __len2 / 2;
      advance(__second_cut, __len22);
      __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
      __len11 += distance(__first, __first_cut);
    }
    _BidirectionalIter __new_middle =
      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
                        __len22, __buffer, __buffer_size);
    __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                     __len22, __buffer, __buffer_size, __comp);
    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                     __len2 - __len22, __buffer, __buffer_size, __comp);
  }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __stable_sort_adaptive(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Pointer __buffer,
                            _Distance __buffer_size, _Compare __comp) {
  _Distance __len = (__last - __first + 1) / 2;
  _RandomAccessIter __middle = __first + __len;
  if (__len > __buffer_size) {
    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                           __comp);
    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                           __comp);
  }
  else {
    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0,
                               __comp);
    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0,
                               __comp);
  }
  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                   _Distance(__last - __middle), __buffer, __buffer_size,
                   __comp);
}

template <class _RandomAccessIter, class _Tp, class _Distance, class _Compare>
void __stable_sort_aux(_RandomAccessIter __first,
         _RandomAccessIter __last, _Tp*, _Distance*,
         _Compare __comp) {
  _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
  if (buf.begin() == 0)
    __inplace_stable_sort(__first, __last, __comp);
  else
    __stable_sort_adaptive(__first, __last, buf.begin(),
                           _Distance(buf.size()),
                           __comp);
}

template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
   _RandomAccessIter __last) {
 
  __stable_sort_aux(__first, __last,
                    (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                    (typename iterator_traits< _RandomAccessIter >::difference_type*)0,
                    __less((typename iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
   _RandomAccessIter __last, _Compare __comp) {
 
  __stable_sort_aux(__first, __last,
                    (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                    (typename iterator_traits< _RandomAccessIter >::difference_type*)0,
                    __comp);
}



template <class _RandomAccessIter, class _Tp, class _Compare>
void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
                    _RandomAccessIter __last, _Tp*, _Compare __comp) {
  make_heap(__first, __middle, __comp);
  for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
    if (__comp(*__i, *__first))
      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,
                 (typename iterator_traits< _RandomAccessIter >::difference_type*)0);
  sort_heap(__first, __middle, __comp);
}


template <class _RandomAccessIter>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle, _RandomAccessIter __last) {
 
 
  __partial_sort(__first, __middle, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                 __less((typename iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last, _Compare __comp) {
 
 
  __partial_sort(__first, __middle, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _InputIter, class _RandomAccessIter, class _Compare,
          class _Distance, class _Tp>
_RandomAccessIter __partial_sort_copy(_InputIter __first,
                                         _InputIter __last,
                                         _RandomAccessIter __result_first,
                                         _RandomAccessIter __result_last,
                                         _Compare __comp, _Distance*, _Tp*) {
  if (__result_first == __result_last) return __result_last;
  _RandomAccessIter __result_real_last = __result_first;
  while(__first != __last && __result_real_last != __result_last) {
    *__result_real_last = *__first;
    ++__result_real_last;
    ++__first;
  }
  make_heap(__result_first, __result_real_last, __comp);
  while (__first != __last) {
    if (__comp(*__first, *__result_first))
      __adjust_heap(__result_first, _Distance(0),
                    _Distance(__result_real_last - __result_first),
                    _Tp(*__first),
                    __comp);
    ++__first;
  }
  sort_heap(__result_first, __result_real_last, __comp);
  return __result_real_last;
}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last) {
 
 
  return __partial_sort_copy(__first, __last, __result_first, __result_last,
                             __less((typename iterator_traits< _InputIter >::value_type*)0),
                             (typename iterator_traits< _RandomAccessIter >::difference_type*)0,
                             (typename iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp) {
 
 
  return __partial_sort_copy(__first, __last, __result_first, __result_last,
                             __comp,
                             (typename iterator_traits< _RandomAccessIter >::difference_type*)0,
                             (typename iterator_traits< _InputIter >::value_type*)0);
}



template <class _RandomAccessIter, class _Tp, class _Compare>
void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                   _RandomAccessIter __last, _Tp*, _Compare __comp) {
  while (__last - __first > 3) {
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1),
                                         __comp)),
                            __comp);
    if (__cut <= __nth)
      __first = __cut;
    else
      __last = __cut;
  }
  __insertion_sort(__first, __last, __comp);
}


template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last) {
 
 
  __nth_element(__first, __nth, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0,
                __less((typename iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp) {
 
 
  __nth_element(__first, __nth, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}



template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
                           const _Tp& __val, _Compare __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    advance(__middle, __half);
    if (__comp(__val, *__middle))
      __len = __half;
    else {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
  }
  return __first;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else if (__comp(__val, *__middle))
      __len = __half;
    else {
      _ForwardIter __left = lower_bound(__first, __middle, __val, __comp);
      advance(__first, __len);
      _ForwardIter __right = upper_bound(++__middle, __first, __val, __comp);
      return pair<_ForwardIter, _ForwardIter>(__left, __right);
    }
  }
  return pair<_ForwardIter, _ForwardIter>(__first, __first);
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first2 < *__first1) {
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return copy(__first2, __last2, copy(__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return copy(__first2, __last2, copy(__first1, __last1, __result));
}

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp) {
  if (__len1 == 0 || __len2 == 0)
    return;
  if (__len1 + __len2 == 2) {
    if (__comp(*__middle, *__first))
      iter_swap(__first, __middle);
    return;
  }
  _BidirectionalIter __first_cut = __first;
  _BidirectionalIter __second_cut = __middle;
  _Distance __len11 = 0;
  _Distance __len22 = 0;
  if (__len1 > __len2) {
    __len11 = __len1 / 2;
    advance(__first_cut, __len11);
    __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
    __len22 += distance(__middle, __second_cut);
  }
  else {
    __len22 = __len2 / 2;
    advance(__second_cut, __len22);
    __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
    __len11 +=distance(__first, __first_cut);
  }
  _BidirectionalIter __new_middle
    = rotate(__first_cut, __middle, __second_cut);
  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,
                         __comp);
  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
                         __len2 - __len22, __comp);
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp) {
  if (__first1 == __last1)
    return copy_backward(__first2, __last2, __result);
  if (__first2 == __last2)
    return copy_backward(__first1, __last1, __result);
  --__last1;
  --__last2;
  while (true) {
    if (__comp(*__last2, *__last1)) {
      *--__result = *__last1;
      if (__first1 == __last1)
        return copy_backward(__first2, ++__last2, __result);
      --__last1;
    }
    else {
      *--__result = *__last2;
      if (__first2 == __last2)
        return copy_backward(__first1, ++__last1, __result);
      --__last2;
    }
  }
}

template <class _BidirectionalIter, class _Tp,
          class _Distance, class _Compare>
inline void __inplace_merge_aux(_BidirectionalIter __first,
                                _BidirectionalIter __middle,
                                _BidirectionalIter __last, _Tp*, _Distance*,
                                _Compare __comp) {
  _Distance __len1 = distance(__first, __middle);
  _Distance __len2 = distance(__middle, __last);

  _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
  if (__buf.begin() == 0)
    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
  else
    __merge_adaptive(__first, __middle, __last, __len1, __len2,
                     __buf.begin(), _Distance(__buf.size()),
                     __comp);
}

template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
     _BidirectionalIter __middle,
     _BidirectionalIter __last) {
 
 
  if (__first == __middle || __middle == __last)
    return;
  __inplace_merge_aux(__first, __middle, __last,
                      (typename iterator_traits< _BidirectionalIter >::value_type*)0, (typename iterator_traits< _BidirectionalIter >::difference_type*)0,
                      __less((typename iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
     _BidirectionalIter __middle,
     _BidirectionalIter __last, _Compare __comp) {
 
 
  if (__first == __middle || __middle == __last)
    return;
  __inplace_merge_aux(__first, __middle, __last,
                      (typename iterator_traits< _BidirectionalIter >::value_type*)0, (typename iterator_traits< _BidirectionalIter >::difference_type*)0,
                      __comp);
}


template <class _InputIter1, class _InputIter2, class _Compare>
bool __includes(_InputIter1 __first1, _InputIter1 __last1,
                _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1))
      return false;
    else if(__comp(*__first1, *__first2))
      ++__first1;
    else
      ++__first1, ++__first2;

  return __first2 == __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
  return __includes(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2) {
  return __includes(__first1, __last1, __first2, __last2, __less((typename iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_union(_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
    }
    else if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
    }
    ++__result;
  }
  return copy(__first2, __last2, copy(__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result) {
  return __set_union(__first1, __last1, __first2, __last2, __result, __less((typename iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp) {
  return __set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                               _InputIter2 __first2, _InputIter2 __last2,
                               _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2))
      ++__first1;
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
      ++__result;
    }
  return __result;
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result) {
  return __set_intersection(__first1, __last1, __first2, __last2, __result, __less((typename iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
  return __set_intersection(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      ++__first1;
      ++__first2;
    }
  return copy(__first1, __last1, __result);
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result) {
  return __set_difference(__first1, __last1, __first2, __last2, __result,
                          __less((typename iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
  return __set_difference(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
__set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
      ++__result;
    }
    else {
      ++__first1;
      ++__first2;
    }
  return copy(__first2, __last2, copy(__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result) {
  return __set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                    __less((typename iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp) {
  return __set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);
}




template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (__comp(*__result, *__first)) __result = __first;
  return __result;
}

template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__result < *__first)
      __result = __first;
  return __result;
}

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__first < *__result)
      __result = __first;
  return __result;
}

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (__comp(*__first, *__result)) __result = __first;
  return __result;
}



template <class _BidirectionalIter, class _Compare>
bool __next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                        _Compare __comp) {
 
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__i, *__ii)) {
      _BidirectionalIter __j = __last;
      while (!__comp(*__i, *--__j))
        {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }



}

template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  return __next_permutation(__first, __last, __less((typename iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
 
  return __next_permutation(__first, __last, __comp);
}

template <class _BidirectionalIter, class _Compare>
bool __prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__ii, *__i)) {
      _BidirectionalIter __j = __last;
      while (!__comp(*--__j, *__i))
        {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }



}

template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  return __prev_permutation(__first, __last, __less((typename iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
 
  return __prev_permutation(__first, __last, __comp);
}
# 1709 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.c"
template <class _RandomAccessIter, class _Distance, class _StrictWeakOrdering>
bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,
               _Distance __n)
{
  _Distance __parent = 0;
  for (_Distance __child = 1; __child < __n; ++__child) {
    if (__comp(__first[__parent], __first[__child]))
      return false;
    if ((__child & 1) == 0)
      ++__parent;
  }
  return true;
}

template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last)
{
 
  return __is_heap(__first, __less((typename iterator_traits< _RandomAccessIter >::value_type*)0), __last - __first);
}

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
      _StrictWeakOrdering __comp)
{
 
  return __is_heap(__first, __comp, __last - __first);
}


template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp)
{
 
  if (__first == __last)
    return true;

  _ForwardIter __next = __first;
  for (++__next; __next != __last; __first = __next, ++__next) {
    if (__comp(*__next, *__first))
      return false;
  }

  return true;
}



}
# 733 "c:/marmalade/6.3/s3e/h/std/c++/stl/_algo.h" 2
# 45 "c:/marmalade/6.3/s3e/h/std/c++/algorithm" 2







# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.3/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.3/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/c++/stl/_epilog.h" 2
# 53 "c:/marmalade/6.3/s3e/h/std/c++/algorithm" 2
# 26 "v:/gigglingbits/box2d/Box2D/Collision/b2BroadPhase.h" 2

struct b2Pair
{
 int32 proxyIdA;
 int32 proxyIdB;
};




class b2BroadPhase
{
public:

 enum
 {
  e_nullProxy = -1
 };

 b2BroadPhase();
 ~b2BroadPhase();



 int32 CreateProxy(const b2AABB& aabb, void* userData);


 void DestroyProxy(int32 proxyId);



 void MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement);


 void TouchProxy(int32 proxyId);


 const b2AABB& GetFatAABB(int32 proxyId) const;


 void* GetUserData(int32 proxyId) const;


 bool TestOverlap(int32 proxyIdA, int32 proxyIdB) const;


 int32 GetProxyCount() const;


 template <typename T>
 void UpdatePairs(T* callback);



 template <typename T>
 void Query(T* callback, const b2AABB& aabb) const;
# 90 "v:/gigglingbits/box2d/Box2D/Collision/b2BroadPhase.h"
 template <typename T>
 void RayCast(T* callback, const b2RayCastInput& input) const;


 int32 GetTreeHeight() const;


 int32 GetTreeBalance() const;


 float32 GetTreeQuality() const;




 void ShiftOrigin(const b2Vec2& newOrigin);

private:

 friend class b2DynamicTree;

 void BufferMove(int32 proxyId);
 void UnBufferMove(int32 proxyId);

 bool QueryCallback(int32 proxyId);

 b2DynamicTree m_tree;

 int32 m_proxyCount;

 int32* m_moveBuffer;
 int32 m_moveCapacity;
 int32 m_moveCount;

 b2Pair* m_pairBuffer;
 int32 m_pairCapacity;
 int32 m_pairCount;

 int32 m_queryProxyId;
};


inline bool b2PairLessThan(const b2Pair& pair1, const b2Pair& pair2)
{
 if (pair1.proxyIdA < pair2.proxyIdA)
 {
  return true;
 }

 if (pair1.proxyIdA == pair2.proxyIdA)
 {
  return pair1.proxyIdB < pair2.proxyIdB;
 }

 return false;
}

inline void* b2BroadPhase::GetUserData(int32 proxyId) const
{
 return m_tree.GetUserData(proxyId);
}

inline bool b2BroadPhase::TestOverlap(int32 proxyIdA, int32 proxyIdB) const
{
 const b2AABB& aabbA = m_tree.GetFatAABB(proxyIdA);
 const b2AABB& aabbB = m_tree.GetFatAABB(proxyIdB);
 return b2TestOverlap(aabbA, aabbB);
}

inline const b2AABB& b2BroadPhase::GetFatAABB(int32 proxyId) const
{
 return m_tree.GetFatAABB(proxyId);
}

inline int32 b2BroadPhase::GetProxyCount() const
{
 return m_proxyCount;
}

inline int32 b2BroadPhase::GetTreeHeight() const
{
 return m_tree.GetHeight();
}

inline int32 b2BroadPhase::GetTreeBalance() const
{
 return m_tree.GetMaxBalance();
}

inline float32 b2BroadPhase::GetTreeQuality() const
{
 return m_tree.GetAreaRatio();
}

template <typename T>
void b2BroadPhase::UpdatePairs(T* callback)
{

 m_pairCount = 0;


 for (int32 i = 0; i < m_moveCount; ++i)
 {
  m_queryProxyId = m_moveBuffer[i];
  if (m_queryProxyId == e_nullProxy)
  {
   continue;
  }



  const b2AABB& fatAABB = m_tree.GetFatAABB(m_queryProxyId);


  m_tree.Query(this, fatAABB);
 }


 m_moveCount = 0;


 _STL::sort(m_pairBuffer, m_pairBuffer + m_pairCount, b2PairLessThan);


 int32 i = 0;
 while (i < m_pairCount)
 {
  b2Pair* primaryPair = m_pairBuffer + i;
  void* userDataA = m_tree.GetUserData(primaryPair->proxyIdA);
  void* userDataB = m_tree.GetUserData(primaryPair->proxyIdB);

  callback->AddPair(userDataA, userDataB);
  ++i;


  while (i < m_pairCount)
  {
   b2Pair* pair = m_pairBuffer + i;
   if (pair->proxyIdA != primaryPair->proxyIdA || pair->proxyIdB != primaryPair->proxyIdB)
   {
    break;
   }
   ++i;
  }
 }



}

template <typename T>
inline void b2BroadPhase::Query(T* callback, const b2AABB& aabb) const
{
 m_tree.Query(callback, aabb);
}

template <typename T>
inline void b2BroadPhase::RayCast(T* callback, const b2RayCastInput& input) const
{
 m_tree.RayCast(callback, input);
}

inline void b2BroadPhase::ShiftOrigin(const b2Vec2& newOrigin)
{
 m_tree.ShiftOrigin(newOrigin);
}
# 23 "v:/gigglingbits/box2d/Box2D/Dynamics/b2ContactManager.h" 2

class b2Contact;
class b2ContactFilter;
class b2ContactListener;
class b2BlockAllocator;


class b2ContactManager
{
public:
 b2ContactManager();


 void AddPair(void* proxyUserDataA, void* proxyUserDataB);

 void FindNewContacts();

 void Destroy(b2Contact* c);

 void Collide();

 b2BroadPhase m_broadPhase;
 b2Contact* m_contactList;
 int32 m_contactCount;
 b2ContactFilter* m_contactFilter;
 b2ContactListener* m_contactListener;
 b2BlockAllocator* m_allocator;
};
# 26 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/b2WorldCallbacks.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Dynamics/b2WorldCallbacks.h"
struct b2Vec2;
struct b2Transform;
class b2Fixture;
class b2Body;
class b2Joint;
class b2Contact;
struct b2ContactResult;
struct b2Manifold;




class b2DestructionListener
{
public:
 virtual ~b2DestructionListener() {}



 virtual void SayGoodbye(b2Joint* joint) = 0;



 virtual void SayGoodbye(b2Fixture* fixture) = 0;
};



class b2ContactFilter
{
public:
 virtual ~b2ContactFilter() {}



 virtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);
};




struct b2ContactImpulse
{
 float32 normalImpulses[2];
 float32 tangentImpulses[2];
 int32 count;
};
# 81 "v:/gigglingbits/box2d/Box2D/Dynamics/b2WorldCallbacks.h"
class b2ContactListener
{
public:
 virtual ~b2ContactListener() {}


 virtual void BeginContact(b2Contact* contact) { ((void)(contact)); }


 virtual void EndContact(b2Contact* contact) { ((void)(contact)); }
# 102 "v:/gigglingbits/box2d/Box2D/Dynamics/b2WorldCallbacks.h"
 virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)
 {
  ((void)(contact));
  ((void)(oldManifold));
 }







 virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)
 {
  ((void)(contact));
  ((void)(impulse));
 }
};



class b2QueryCallback
{
public:
 virtual ~b2QueryCallback() {}



 virtual bool ReportFixture(b2Fixture* fixture) = 0;
};



class b2RayCastCallback
{
public:
 virtual ~b2RayCastCallback() {}
# 151 "v:/gigglingbits/box2d/Box2D/Dynamics/b2WorldCallbacks.h"
 virtual float32 ReportFixture( b2Fixture* fixture, const b2Vec2& point,
         const b2Vec2& normal, float32 fraction) = 0;
};
# 27 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h" 2
# 1 "v:/gigglingbits/box2d/Box2D/Dynamics/b2TimeStep.h" 1
# 25 "v:/gigglingbits/box2d/Box2D/Dynamics/b2TimeStep.h"
struct b2Profile
{
 float32 step;
 float32 collide;
 float32 solve;
 float32 solveInit;
 float32 solveVelocity;
 float32 solvePosition;
 float32 broadphase;
 float32 solveTOI;
};


struct b2TimeStep
{
 float32 dt;
 float32 inv_dt;
 float32 dtRatio;
 int32 velocityIterations;
 int32 positionIterations;
 bool warmStarting;
};


struct b2Position
{
 b2Vec2 c;
 float32 a;
};


struct b2Velocity
{
 b2Vec2 v;
 float32 w;
};


struct b2SolverData
{
 b2TimeStep step;
 b2Position* positions;
 b2Velocity* velocities;
};
# 28 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h" 2

struct b2AABB;
struct b2BodyDef;
struct b2Color;
struct b2JointDef;
class b2Body;
class b2Draw;
class b2Fixture;
class b2Joint;




class b2World
{
public:


 b2World(const b2Vec2& gravity);


 ~b2World();



 void SetDestructionListener(b2DestructionListener* listener);




 void SetContactFilter(b2ContactFilter* filter);



 void SetContactListener(b2ContactListener* listener);




 void SetDebugDraw(b2Draw* debugDraw);




 b2Body* CreateBody(const b2BodyDef* def);





 void DestroyBody(b2Body* body);




 b2Joint* CreateJoint(const b2JointDef* def);



 void DestroyJoint(b2Joint* joint);






 void Step( float32 timeStep,
    int32 velocityIterations,
    int32 positionIterations);
# 105 "v:/gigglingbits/box2d/Box2D/Dynamics/b2World.h"
 void ClearForces();


 void DrawDebugData();





 void QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;







 void RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;




 b2Body* GetBodyList();
 const b2Body* GetBodyList() const;




 b2Joint* GetJointList();
 const b2Joint* GetJointList() const;






 b2Contact* GetContactList();
 const b2Contact* GetContactList() const;


 void SetAllowSleeping(bool flag);
 bool GetAllowSleeping() const { return m_allowSleep; }


 void SetWarmStarting(bool flag) { m_warmStarting = flag; }
 bool GetWarmStarting() const { return m_warmStarting; }


 void SetContinuousPhysics(bool flag) { m_continuousPhysics = flag; }
 bool GetContinuousPhysics() const { return m_continuousPhysics; }


 void SetSubStepping(bool flag) { m_subStepping = flag; }
 bool GetSubStepping() const { return m_subStepping; }


 int32 GetProxyCount() const;


 int32 GetBodyCount() const;


 int32 GetJointCount() const;


 int32 GetContactCount() const;


 int32 GetTreeHeight() const;


 int32 GetTreeBalance() const;



 float32 GetTreeQuality() const;


 void SetGravity(const b2Vec2& gravity);


 b2Vec2 GetGravity() const;


 bool IsLocked() const;


 void SetAutoClearForces(bool flag);


 bool GetAutoClearForces() const;




 void ShiftOrigin(const b2Vec2& newOrigin);


 const b2ContactManager& GetContactManager() const;


 const b2Profile& GetProfile() const;



 void Dump();

private:


 enum
 {
  e_newFixture = 0x0001,
  e_locked = 0x0002,
  e_clearForces = 0x0004
 };

 friend class b2Body;
 friend class b2Fixture;
 friend class b2ContactManager;
 friend class b2Controller;

 void Solve(const b2TimeStep& step);
 void SolveTOI(const b2TimeStep& step);

 void DrawJoint(b2Joint* joint);
 void DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);

 b2BlockAllocator m_blockAllocator;
 b2StackAllocator m_stackAllocator;

 int32 m_flags;

 b2ContactManager m_contactManager;

 b2Body* m_bodyList;
 b2Joint* m_jointList;

 int32 m_bodyCount;
 int32 m_jointCount;

 b2Vec2 m_gravity;
 bool m_allowSleep;

 b2DestructionListener* m_destructionListener;
 b2Draw* m_debugDraw;



 float32 m_inv_dt0;


 bool m_warmStarting;
 bool m_continuousPhysics;
 bool m_subStepping;

 bool m_stepComplete;

 b2Profile m_profile;
};

inline b2Body* b2World::GetBodyList()
{
 return m_bodyList;
}

inline const b2Body* b2World::GetBodyList() const
{
 return m_bodyList;
}

inline b2Joint* b2World::GetJointList()
{
 return m_jointList;
}

inline const b2Joint* b2World::GetJointList() const
{
 return m_jointList;
}

inline b2Contact* b2World::GetContactList()
{
 return m_contactManager.m_contactList;
}

inline const b2Contact* b2World::GetContactList() const
{
 return m_contactManager.m_contactList;
}

inline int32 b2World::GetBodyCount() const
{
 return m_bodyCount;
}

inline int32 b2World::GetJointCount() const
{
 return m_jointCount;
}

inline int32 b2World::GetContactCount() const
{
 return m_contactManager.m_contactCount;
}

inline void b2World::SetGravity(const b2Vec2& gravity)
{
 m_gravity = gravity;
}

inline b2Vec2 b2World::GetGravity() const
{
 return m_gravity;
}

inline bool b2World::IsLocked() const
{
 return (m_flags & e_locked) == e_locked;
}

inline void b2World::SetAutoClearForces(bool flag)
{
 if (flag)
 {
  m_flags |= e_clearForces;
 }
 else
 {
  m_flags &= ~e_clearForces;
 }
}


inline bool b2World::GetAutoClearForces() const
{
 return (m_flags & e_clearForces) == e_clearForces;
}

inline const b2ContactManager& b2World::GetContactManager() const
{
 return m_contactManager;
}

inline const b2Profile& b2World::GetProfile() const
{
 return m_profile;
}
# 33 "v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp" 2




b2Joint* b2Joint::Create(const b2JointDef* def, b2BlockAllocator* allocator)
{
 b2Joint* joint = __null;

 switch (def->type)
 {
 case e_distanceJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2DistanceJoint));
   joint = new (mem) b2DistanceJoint(static_cast<const b2DistanceJointDef*>(def));
  }
  break;

 case e_mouseJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2MouseJoint));
   joint = new (mem) b2MouseJoint(static_cast<const b2MouseJointDef*>(def));
  }
  break;

 case e_prismaticJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2PrismaticJoint));
   joint = new (mem) b2PrismaticJoint(static_cast<const b2PrismaticJointDef*>(def));
  }
  break;

 case e_revoluteJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2RevoluteJoint));
   joint = new (mem) b2RevoluteJoint(static_cast<const b2RevoluteJointDef*>(def));
  }
  break;

 case e_pulleyJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2PulleyJoint));
   joint = new (mem) b2PulleyJoint(static_cast<const b2PulleyJointDef*>(def));
  }
  break;

 case e_gearJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2GearJoint));
   joint = new (mem) b2GearJoint(static_cast<const b2GearJointDef*>(def));
  }
  break;

 case e_wheelJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2WheelJoint));
   joint = new (mem) b2WheelJoint(static_cast<const b2WheelJointDef*>(def));
  }
  break;

 case e_weldJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2WeldJoint));
   joint = new (mem) b2WeldJoint(static_cast<const b2WeldJointDef*>(def));
  }
  break;

 case e_frictionJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2FrictionJoint));
   joint = new (mem) b2FrictionJoint(static_cast<const b2FrictionJointDef*>(def));
  }
  break;

 case e_ropeJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2RopeJoint));
   joint = new (mem) b2RopeJoint(static_cast<const b2RopeJointDef*>(def));
  }
  break;

 case e_motorJoint:
  {
   void* mem = allocator->Allocate(sizeof(b2MotorJoint));
   joint = new (mem) b2MotorJoint(static_cast<const b2MotorJointDef*>(def));
  }
  break;

 default:
  ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp", 121, "false"));
  break;
 }

 return joint;
}

void b2Joint::Destroy(b2Joint* joint, b2BlockAllocator* allocator)
{
 joint->~b2Joint();
 switch (joint->m_type)
 {
 case e_distanceJoint:
  allocator->Free(joint, sizeof(b2DistanceJoint));
  break;

 case e_mouseJoint:
  allocator->Free(joint, sizeof(b2MouseJoint));
  break;

 case e_prismaticJoint:
  allocator->Free(joint, sizeof(b2PrismaticJoint));
  break;

 case e_revoluteJoint:
  allocator->Free(joint, sizeof(b2RevoluteJoint));
  break;

 case e_pulleyJoint:
  allocator->Free(joint, sizeof(b2PulleyJoint));
  break;

 case e_gearJoint:
  allocator->Free(joint, sizeof(b2GearJoint));
  break;

 case e_wheelJoint:
  allocator->Free(joint, sizeof(b2WheelJoint));
  break;

 case e_weldJoint:
  allocator->Free(joint, sizeof(b2WeldJoint));
  break;

 case e_frictionJoint:
  allocator->Free(joint, sizeof(b2FrictionJoint));
  break;

 case e_ropeJoint:
  allocator->Free(joint, sizeof(b2RopeJoint));
  break;

 case e_motorJoint:
  allocator->Free(joint, sizeof(b2MotorJoint));
  break;

 default:
  ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp", 178, "false"));
  break;
 }
}

b2Joint::b2Joint(const b2JointDef* def)
{
 ((def->bodyA != def->bodyB) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Dynamics/Joints/b2Joint.cpp", 185, "def->bodyA != def->bodyB"));

 m_type = def->type;
 m_prev = __null;
 m_next = __null;
 m_bodyA = def->bodyA;
 m_bodyB = def->bodyB;
 m_index = 0;
 m_collideConnected = def->collideConnected;
 m_islandFlag = false;
 m_userData = def->userData;

 m_edgeA.joint = __null;
 m_edgeA.other = __null;
 m_edgeA.prev = __null;
 m_edgeA.next = __null;

 m_edgeB.joint = __null;
 m_edgeB.other = __null;
 m_edgeB.prev = __null;
 m_edgeB.next = __null;
}

bool b2Joint::IsActive() const
{
 return m_bodyA->IsActive() && m_bodyB->IsActive();
}
