# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp"
# 1 "v:\\GigglingBits\\box2d\\HeyBox2D\\build_heybox2d_vc11//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "v:/GigglingBits/box2d/HeyBox2D/build_heybox2d_vc11/temp_defines_debug.h" 1
# 1 "<command-line>" 2
# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp"
# 19 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp"
# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.h" 1
# 23 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h"
# 1 "c:/marmalade/6.3/s3e/h/std/stddef.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 23 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/assert.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/assert.h"
# 1 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/6.3/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/6.3/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 72 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 94 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 106 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 224 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 242 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 254 "c:/marmalade/6.3/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2

# 1 "c:/marmalade/6.3/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/6.3/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/6.3/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/6.3/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/6.3/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/6.3/s3e/h/std/assert.h" 2

extern "C" {
# 33 "c:/marmalade/6.3/s3e/h/std/assert.h"
        void __assert(const char* file, int line, const char* expr);
# 43 "c:/marmalade/6.3/s3e/h/std/assert.h"
}
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/float.h" 1
# 31 "c:/marmalade/6.3/s3e/h/std/float.h"
  extern "C" {
# 109 "c:/marmalade/6.3/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/6.3/s3e/h/std/float.h"
    }
# 25 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h" 2




typedef signed char int8;
typedef signed short int16;
typedef signed int int32;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef float float32;
typedef double float64;
# 131 "v:/gigglingbits/box2d/Box2D/Common/b2Settings.h"
void* b2Alloc(int32 size);


void b2Free(void* mem);


void b2Log(const char* string, ...);



struct b2Version
{
 int32 major;
 int32 minor;
 int32 revision;
};


extern b2Version b2_version;
# 23 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 2
# 1 "c:/marmalade/6.3/s3e/h/std/math.h" 1
# 17 "c:/marmalade/6.3/s3e/h/std/math.h"
extern "C" {
# 48 "c:/marmalade/6.3/s3e/h/std/math.h"
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);

double sin(double x);
float sinf(float x);
long double sinl(long double x);

double asin(double x);
float asinf(float x);
long double asinl(long double x);

double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);

double cos(double x);
float cosf(float x);
long double cosl(long double x);

double cosh(double x);
float coshf(float x);
long double coshl(long double x);

double acos(double x);
float acosf(float x);
long double acosl(long double x);

double tan(double x);
float tanf(float x);
long double tanl(long double x);

double atan(double x);
float atanf(float x);
long double atanl(long double x);

double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);

double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);

double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);

double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

double floor(double x);
float floorf(float x);
long double floorl(long double x);

double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);

double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);

double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);

double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);

double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);

double modf(double x, double *iptr);
float modff(float x, float *iptr);
long double modfl(long double x, long double *iptr);

double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);

double exp(double x);
float expf(float x);
long double expl(long double x);

double log(double x);
float logf(float x);
long double logl(long double x);

double log10(double x);
float log10f(float x);
long double log10l(long double x);

double rint(double x);
float rintf(float x);
long double rintl(long double x);

double round(double x);
float roundf(float x);
long double roundl(long double x);

double frexp(double x, int *exp);
float frexpf(float x, int *exp);
long double frexpl(long double x, int *exp);

long int lround(double x);
long int lroundf(float x);
long int lroundl(long double x);

int64 llround(double x);
int64 llroundf(float x);
int64 llroundl(long double x);

double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);

double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);

double trunc(double x);
float truncf(float x);
long double truncl(long double x);

double hypot(double x, double y);

double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);

int finite(double x);
# 196 "c:/marmalade/6.3/s3e/h/std/math.h"
# 1 "c:/marmalade/6.3/s3e/h/std/math_gcc.h" 1
# 33 "c:/marmalade/6.3/s3e/h/std/math_gcc.h"
int __isnanf(float);
int __isnand(double);
int __isinff(float);
int __isinfd(double);
int __signbitf(float);
int __signbitd(double);
int __fpclassifyf(float);
int __fpclassifyd(double);
int __fpclassifyl(long double);
# 197 "c:/marmalade/6.3/s3e/h/std/math.h" 2
# 222 "c:/marmalade/6.3/s3e/h/std/math.h"
}
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2Math.h" 2


inline bool b2IsValid(float32 x)
{
 int32 ix = *reinterpret_cast<int32*>(&x);
 return (ix & 0x7f800000) != 0x7f800000;
}


inline float32 b2InvSqrt(float32 x)
{
 union
 {
  float32 x;
  int32 i;
 } convert;

 convert.x = x;
 float32 xhalf = 0.5f * x;
 convert.i = 0x5f3759df - (convert.i >> 1);
 x = convert.x;
 x = x * (1.5f - xhalf * x * x);
 return x;
}





struct b2Vec2
{

 b2Vec2() {}


 b2Vec2(float32 x, float32 y) : x(x), y(y) {}


 void SetZero() { x = 0.0f; y = 0.0f; }


 void Set(float32 x_, float32 y_) { x = x_; y = y_; }


 b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }


 float32 operator () (int32 i) const
 {
  return (&x)[i];
 }


 float32& operator () (int32 i)
 {
  return (&x)[i];
 }


 void operator += (const b2Vec2& v)
 {
  x += v.x; y += v.y;
 }


 void operator -= (const b2Vec2& v)
 {
  x -= v.x; y -= v.y;
 }


 void operator *= (float32 a)
 {
  x *= a; y *= a;
 }


 float32 Length() const
 {
  return sqrtf(x * x + y * y);
 }



 float32 LengthSquared() const
 {
  return x * x + y * y;
 }


 float32 Normalize()
 {
  float32 length = Length();
  if (length < 1.19209290e-7F)
  {
   return 0.0f;
  }
  float32 invLength = 1.0f / length;
  x *= invLength;
  y *= invLength;

  return length;
 }


 bool IsValid() const
 {
  return b2IsValid(x) && b2IsValid(y);
 }


 b2Vec2 Skew() const
 {
  return b2Vec2(-y, x);
 }

 float32 x, y;
};


struct b2Vec3
{

 b2Vec3() {}


 b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}


 void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }


 void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }


 b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }


 void operator += (const b2Vec3& v)
 {
  x += v.x; y += v.y; z += v.z;
 }


 void operator -= (const b2Vec3& v)
 {
  x -= v.x; y -= v.y; z -= v.z;
 }


 void operator *= (float32 s)
 {
  x *= s; y *= s; z *= s;
 }

 float32 x, y, z;
};


struct b2Mat22
{

 b2Mat22() {}


 b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
 {
  ex.x = a11; ex.y = a21;
  ey.x = a12; ey.y = a22;
 }


 void Set(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 void SetIdentity()
 {
  ex.x = 1.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 1.0f;
 }


 void SetZero()
 {
  ex.x = 0.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 0.0f;
 }

 b2Mat22 GetInverse() const
 {
  float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
  b2Mat22 B;
  float32 det = a * d - b * c;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  B.ex.x = det * d; B.ey.x = -det * b;
  B.ex.y = -det * c; B.ey.y = det * a;
  return B;
 }



 b2Vec2 Solve(const b2Vec2& b) const
 {
  float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
  float32 det = a11 * a22 - a12 * a21;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  b2Vec2 x;
  x.x = det * (a22 * b.x - a12 * b.y);
  x.y = det * (a11 * b.y - a21 * b.x);
  return x;
 }

 b2Vec2 ex, ey;
};


struct b2Mat33
{

 b2Mat33() {}


 b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
 {
  ex = c1;
  ey = c2;
  ez = c3;
 }


 void SetZero()
 {
  ex.SetZero();
  ey.SetZero();
  ez.SetZero();
 }



 b2Vec3 Solve33(const b2Vec3& b) const;




 b2Vec2 Solve22(const b2Vec2& b) const;



 void GetInverse22(b2Mat33* M) const;



 void GetSymInverse33(b2Mat33* M) const;

 b2Vec3 ex, ey, ez;
};


struct b2Rot
{
 b2Rot() {}


 explicit b2Rot(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void Set(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void SetIdentity()
 {
  s = 0.0f;
  c = 1.0f;
 }


 float32 GetAngle() const
 {
  return atan2f(s, c);
 }


 b2Vec2 GetXAxis() const
 {
  return b2Vec2(c, s);
 }


 b2Vec2 GetYAxis() const
 {
  return b2Vec2(-s, c);
 }


 float32 s, c;
};



struct b2Transform
{

 b2Transform() {}


 b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}


 void SetIdentity()
 {
  p.SetZero();
  q.SetIdentity();
 }


 void Set(const b2Vec2& position, float32 angle)
 {
  p = position;
  q.Set(angle);
 }

 b2Vec2 p;
 b2Rot q;
};





struct b2Sweep
{


 void GetTransform(b2Transform* xfb, float32 beta) const;



 void Advance(float32 alpha);


 void Normalize();

 b2Vec2 localCenter;
 b2Vec2 c0, c;
 float32 a0, a;



 float32 alpha0;
};


extern const b2Vec2 b2Vec2_zero;


inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.x + a.y * b.y;
}


inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.y - a.y * b.x;
}



inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
{
 return b2Vec2(s * a.y, -s * a.x);
}



inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
{
 return b2Vec2(-s * a.y, s * a.x);
}



inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}



inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
}


inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x + b.x, a.y + b.y);
}


inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x - b.x, a.y - b.y);
}

inline b2Vec2 operator * (float32 s, const b2Vec2& a)
{
 return b2Vec2(s * a.x, s * a.y);
}

inline bool operator == (const b2Vec2& a, const b2Vec2& b)
{
 return a.x == b.x && a.y == b.y;
}

inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return c.Length();
}

inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return b2Dot(c, c);
}

inline b2Vec3 operator * (float32 s, const b2Vec3& a)
{
 return b2Vec3(s * a.x, s * a.y, s * a.z);
}


inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
}


inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
}


inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z;
}


inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(A.ex + B.ex, A.ey + B.ey);
}


inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
}


inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
{
 b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
 b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
 return b2Mat22(c1, c2);
}


inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
{
 return v.x * A.ex + v.y * A.ey + v.z * A.ez;
}


inline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}


inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.s * r.c + q.c * r.s;
 qr.c = q.c * r.c - q.s * r.s;
 return qr;
}


inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.c * r.s - q.s * r.c;
 qr.c = q.c * r.c + q.s * r.s;
 return qr;
}


inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
}


inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
}

inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
{
 float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
 float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;

 return b2Vec2(x, y);
}

inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
{
 float32 px = v.x - T.p.x;
 float32 py = v.y - T.p.y;
 float32 x = (T.q.c * px + T.q.s * py);
 float32 y = (-T.q.s * px + T.q.c * py);

 return b2Vec2(x, y);
}



inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2Mul(A.q, B.q);
 C.p = b2Mul(A.q, B.p) + A.p;
 return C;
}



inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2MulT(A.q, B.q);
 C.p = b2MulT(A.q, B.p - A.p);
 return C;
}

template <typename T>
inline T b2Abs(T a)
{
 return a > T(0) ? a : -a;
}

inline b2Vec2 b2Abs(const b2Vec2& a)
{
 return b2Vec2(b2Abs(a.x), b2Abs(a.y));
}

inline b2Mat22 b2Abs(const b2Mat22& A)
{
 return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
}

template <typename T>
inline T b2Min(T a, T b)
{
 return a < b ? a : b;
}

inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
}

template <typename T>
inline T b2Max(T a, T b)
{
 return a > b ? a : b;
}

inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
}

template <typename T>
inline T b2Clamp(T a, T low, T high)
{
 return b2Max(low, b2Min(a, high));
}

inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
{
 return b2Max(low, b2Min(a, high));
}

template<typename T> inline void b2Swap(T& a, T& b)
{
 T tmp = a;
 a = b;
 b = tmp;
}






inline uint32 b2NextPowerOfTwo(uint32 x)
{
 x |= (x >> 1);
 x |= (x >> 2);
 x |= (x >> 4);
 x |= (x >> 8);
 x |= (x >> 16);
 return x + 1;
}

inline bool b2IsPowerOfTwo(uint32 x)
{
 bool result = x > 0 && (x & (x - 1)) == 0;
 return result;
}

inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
{
 xf->p = (1.0f - beta) * c0 + beta * c;
 float32 angle = (1.0f - beta) * a0 + beta * a;
 xf->q.Set(angle);


 xf->p -= b2Mul(xf->q, localCenter);
}

inline void b2Sweep::Advance(float32 alpha)
{
 ((alpha0 < 1.0f) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Common/b2Math.h", 704, "alpha0 < 1.0f"));
 float32 beta = (alpha - alpha0) / (1.0f - alpha0);
 c0 += beta * (c - c0);
 a0 += beta * (a - a0);
 alpha0 = alpha;
}


inline void b2Sweep::Normalize()
{
 float32 twoPi = 2.0f * 3.14159265359f;
 float32 d = twoPi * floorf(a0 / twoPi);
 a0 -= d;
 a -= d;
}
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.h" 2

class b2Shape;



struct b2DistanceProxy
{
 b2DistanceProxy() : m_vertices(__null), m_count(0), m_radius(0.0f) {}



 void Set(const b2Shape* shape, int32 index);


 int32 GetSupport(const b2Vec2& d) const;


 const b2Vec2& GetSupportVertex(const b2Vec2& d) const;


 int32 GetVertexCount() const;


 const b2Vec2& GetVertex(int32 index) const;

 b2Vec2 m_buffer[2];
 const b2Vec2* m_vertices;
 int32 m_count;
 float32 m_radius;
};



struct b2SimplexCache
{
 float32 metric;
 uint16 count;
 uint8 indexA[3];
 uint8 indexB[3];
};




struct b2DistanceInput
{
 b2DistanceProxy proxyA;
 b2DistanceProxy proxyB;
 b2Transform transformA;
 b2Transform transformB;
 bool useRadii;
};


struct b2DistanceOutput
{
 b2Vec2 pointA;
 b2Vec2 pointB;
 float32 distance;
 int32 iterations;
};




void b2Distance(b2DistanceOutput* output,
    b2SimplexCache* cache,
    const b2DistanceInput* input);




inline int32 b2DistanceProxy::GetVertexCount() const
{
 return m_count;
}

inline const b2Vec2& b2DistanceProxy::GetVertex(int32 index) const
{
 ((0 <= index && index < m_count) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.h", 103, "0 <= index && index < m_count"));
 return m_vertices[index];
}

inline int32 b2DistanceProxy::GetSupport(const b2Vec2& d) const
{
 int32 bestIndex = 0;
 float32 bestValue = b2Dot(m_vertices[0], d);
 for (int32 i = 1; i < m_count; ++i)
 {
  float32 value = b2Dot(m_vertices[i], d);
  if (value > bestValue)
  {
   bestIndex = i;
   bestValue = value;
  }
 }

 return bestIndex;
}

inline const b2Vec2& b2DistanceProxy::GetSupportVertex(const b2Vec2& d) const
{
 int32 bestIndex = 0;
 float32 bestValue = b2Dot(m_vertices[0], d);
 for (int32 i = 1; i < m_count; ++i)
 {
  float32 value = b2Dot(m_vertices[i], d);
  if (value > bestValue)
  {
   bestIndex = i;
   bestValue = value;
  }
 }

 return m_vertices[bestIndex];
}
# 20 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2CircleShape.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2CircleShape.h"
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 1
# 22 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h"
# 1 "v:/gigglingbits/box2d/Box2D/Common/b2BlockAllocator.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Common/b2BlockAllocator.h"
const int32 b2_chunkSize = 16 * 1024;
const int32 b2_maxBlockSize = 640;
const int32 b2_blockSizes = 14;
const int32 b2_chunkArrayIncrement = 128;

struct b2Block;
struct b2Chunk;




class b2BlockAllocator
{
public:
 b2BlockAllocator();
 ~b2BlockAllocator();


 void* Allocate(int32 size);


 void Free(void* p, int32 size);

 void Clear();

private:

 b2Chunk* m_chunks;
 int32 m_chunkCount;
 int32 m_chunkSpace;

 b2Block* m_freeLists[b2_blockSizes];

 static int32 s_blockSizes[b2_blockSizes];
 static uint8 s_blockSizeLookup[b2_maxBlockSize + 1];
 static bool s_blockSizeLookupInitialized;
};
# 23 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 2

# 1 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h" 1
# 23 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
# 1 "c:/marmalade/6.3/s3e/h/std/limits.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h" 2





class b2Shape;
class b2CircleShape;
class b2EdgeShape;
class b2PolygonShape;

const uint8 b2_nullFeature = 255;



struct b2ContactFeature
{
 enum Type
 {
  e_vertex = 0,
  e_face = 1
 };

 uint8 indexA;
 uint8 indexB;
 uint8 typeA;
 uint8 typeB;
};


union b2ContactID
{
 b2ContactFeature cf;
 uint32 key;
};
# 69 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
struct b2ManifoldPoint
{
 b2Vec2 localPoint;
 float32 normalImpulse;
 float32 tangentImpulse;
 b2ContactID id;
};
# 93 "v:/gigglingbits/box2d/Box2D/Collision/b2Collision.h"
struct b2Manifold
{
 enum Type
 {
  e_circles,
  e_faceA,
  e_faceB
 };

 b2ManifoldPoint points[2];
 b2Vec2 localNormal;
 b2Vec2 localPoint;
 Type type;
 int32 pointCount;
};


struct b2WorldManifold
{




 void Initialize(const b2Manifold* manifold,
     const b2Transform& xfA, float32 radiusA,
     const b2Transform& xfB, float32 radiusB);

 b2Vec2 normal;
 b2Vec2 points[2];
 float32 separations[2];
};


enum b2PointState
{
 b2_nullState,
 b2_addState,
 b2_persistState,
 b2_removeState
};



void b2GetPointStates(b2PointState state1[2], b2PointState state2[2],
       const b2Manifold* manifold1, const b2Manifold* manifold2);


struct b2ClipVertex
{
 b2Vec2 v;
 b2ContactID id;
};


struct b2RayCastInput
{
 b2Vec2 p1, p2;
 float32 maxFraction;
};



struct b2RayCastOutput
{
 b2Vec2 normal;
 float32 fraction;
};


struct b2AABB
{

 bool IsValid() const;


 b2Vec2 GetCenter() const
 {
  return 0.5f * (lowerBound + upperBound);
 }


 b2Vec2 GetExtents() const
 {
  return 0.5f * (upperBound - lowerBound);
 }


 float32 GetPerimeter() const
 {
  float32 wx = upperBound.x - lowerBound.x;
  float32 wy = upperBound.y - lowerBound.y;
  return 2.0f * (wx + wy);
 }


 void Combine(const b2AABB& aabb)
 {
  lowerBound = b2Min(lowerBound, aabb.lowerBound);
  upperBound = b2Max(upperBound, aabb.upperBound);
 }


 void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
 {
  lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
  upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
 }


 bool Contains(const b2AABB& aabb) const
 {
  bool result = true;
  result = result && lowerBound.x <= aabb.lowerBound.x;
  result = result && lowerBound.y <= aabb.lowerBound.y;
  result = result && aabb.upperBound.x <= upperBound.x;
  result = result && aabb.upperBound.y <= upperBound.y;
  return result;
 }

 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;

 b2Vec2 lowerBound;
 b2Vec2 upperBound;
};


void b2CollideCircles(b2Manifold* manifold,
       const b2CircleShape* circleA, const b2Transform& xfA,
       const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygonAndCircle(b2Manifold* manifold,
          const b2PolygonShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygons(b2Manifold* manifold,
        const b2PolygonShape* polygonA, const b2Transform& xfA,
        const b2PolygonShape* polygonB, const b2Transform& xfB);


void b2CollideEdgeAndCircle(b2Manifold* manifold,
          const b2EdgeShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollideEdgeAndPolygon(b2Manifold* manifold,
          const b2EdgeShape* edgeA, const b2Transform& xfA,
          const b2PolygonShape* circleB, const b2Transform& xfB);


int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
       const b2Vec2& normal, float32 offset, int32 vertexIndexA);


bool b2TestOverlap( const b2Shape* shapeA, int32 indexA,
     const b2Shape* shapeB, int32 indexB,
     const b2Transform& xfA, const b2Transform& xfB);



inline bool b2AABB::IsValid() const
{
 b2Vec2 d = upperBound - lowerBound;
 bool valid = d.x >= 0.0f && d.y >= 0.0f;
 valid = valid && lowerBound.IsValid() && upperBound.IsValid();
 return valid;
}

inline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)
{
 b2Vec2 d1, d2;
 d1 = b.lowerBound - a.upperBound;
 d2 = a.lowerBound - b.upperBound;

 if (d1.x > 0.0f || d1.y > 0.0f)
  return false;

 if (d2.x > 0.0f || d2.y > 0.0f)
  return false;

 return true;
}
# 25 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2Shape.h" 2


struct b2MassData
{

 float32 mass;


 b2Vec2 center;


 float32 I;
};




class b2Shape
{
public:

 enum Type
 {
  e_circle = 0,
  e_edge = 1,
  e_polygon = 2,
  e_chain = 3,
  e_typeCount = 4
 };

 virtual ~b2Shape() {}


 virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;



 Type GetType() const;


 virtual int32 GetChildCount() const = 0;




 virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;






 virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
      const b2Transform& transform, int32 childIndex) const = 0;





 virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;





 virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;

 Type m_type;
 float32 m_radius;
};

inline b2Shape::Type b2Shape::GetType() const
{
 return m_type;
}
# 23 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2CircleShape.h" 2


class b2CircleShape : public b2Shape
{
public:
 b2CircleShape();


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
    const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 int32 GetSupport(const b2Vec2& d) const;


 const b2Vec2& GetSupportVertex(const b2Vec2& d) const;


 int32 GetVertexCount() const { return 1; }


 const b2Vec2& GetVertex(int32 index) const;


 b2Vec2 m_p;
};

inline b2CircleShape::b2CircleShape()
{
 m_type = e_circle;
 m_radius = 0.0f;
 m_p.SetZero();
}

inline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const
{
 ((void)(d));
 return 0;
}

inline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const
{
 ((void)(d));
 return m_p;
}

inline const b2Vec2& b2CircleShape::GetVertex(int32 index) const
{
 ((void)(index));
 ((index == 0) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2CircleShape.h", 87, "index == 0"));
 return m_p;
}
# 21 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2EdgeShape.h" 1
# 27 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2EdgeShape.h"
class b2EdgeShape : public b2Shape
{
public:
 b2EdgeShape();


 void Set(const b2Vec2& v1, const b2Vec2& v2);


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
    const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 b2Vec2 m_vertex1, m_vertex2;


 b2Vec2 m_vertex0, m_vertex3;
 bool m_hasVertex0, m_hasVertex3;
};

inline b2EdgeShape::b2EdgeShape()
{
 m_type = e_edge;
 m_radius = (2.0f * 0.005f);
 m_vertex0.x = 0.0f;
 m_vertex0.y = 0.0f;
 m_vertex3.x = 0.0f;
 m_vertex3.y = 0.0f;
 m_hasVertex0 = false;
 m_hasVertex3 = false;
}
# 22 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2ChainShape.h" 1
# 24 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2ChainShape.h"
class b2EdgeShape;







class b2ChainShape : public b2Shape
{
public:
 b2ChainShape();


 ~b2ChainShape();




 void CreateLoop(const b2Vec2* vertices, int32 count);




 void CreateChain(const b2Vec2* vertices, int32 count);



 void SetPrevVertex(const b2Vec2& prevVertex);



 void SetNextVertex(const b2Vec2& nextVertex);


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 void GetChildEdge(b2EdgeShape* edge, int32 index) const;



 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
     const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;



 void ComputeMass(b2MassData* massData, float32 density) const;


 b2Vec2* m_vertices;


 int32 m_count;

 b2Vec2 m_prevVertex, m_nextVertex;
 bool m_hasPrevVertex, m_hasNextVertex;
};

inline b2ChainShape::b2ChainShape()
{
 m_type = e_chain;
 m_radius = (2.0f * 0.005f);
 m_vertices = __null;
 m_count = 0;
 m_hasPrevVertex = false;
 m_hasNextVertex = false;
}
# 23 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp" 2
# 1 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2PolygonShape.h" 1
# 28 "v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2PolygonShape.h"
class b2PolygonShape : public b2Shape
{
public:
 b2PolygonShape();


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;






 void Set(const b2Vec2* points, int32 count);




 void SetAsBox(float32 hx, float32 hy);






 void SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle);


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
     const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 int32 GetVertexCount() const { return m_count; }


 const b2Vec2& GetVertex(int32 index) const;



 bool Validate() const;

 b2Vec2 m_centroid;
 b2Vec2 m_vertices[8];
 b2Vec2 m_normals[8];
 int32 m_count;
};

inline b2PolygonShape::b2PolygonShape()
{
 m_type = e_polygon;
 m_radius = (2.0f * 0.005f);
 m_count = 0;
 m_centroid.SetZero();
}

inline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const
{
 ((0 <= index && index < m_count) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/Shapes/b2PolygonShape.h", 97, "0 <= index && index < m_count"));
 return m_vertices[index];
}
# 24 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp" 2


int32 b2_gjkCalls, b2_gjkIters, b2_gjkMaxIters;

void b2DistanceProxy::Set(const b2Shape* shape, int32 index)
{
 switch (shape->GetType())
 {
 case b2Shape::e_circle:
  {
   const b2CircleShape* circle = static_cast<const b2CircleShape*>(shape);
   m_vertices = &circle->m_p;
   m_count = 1;
   m_radius = circle->m_radius;
  }
  break;

 case b2Shape::e_polygon:
  {
   const b2PolygonShape* polygon = static_cast<const b2PolygonShape*>(shape);
   m_vertices = polygon->m_vertices;
   m_count = polygon->m_count;
   m_radius = polygon->m_radius;
  }
  break;

 case b2Shape::e_chain:
  {
   const b2ChainShape* chain = static_cast<const b2ChainShape*>(shape);
   ((0 <= index && index < chain->m_count) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 53, "0 <= index && index < chain->m_count"));

   m_buffer[0] = chain->m_vertices[index];
   if (index + 1 < chain->m_count)
   {
    m_buffer[1] = chain->m_vertices[index + 1];
   }
   else
   {
    m_buffer[1] = chain->m_vertices[0];
   }

   m_vertices = m_buffer;
   m_count = 2;
   m_radius = chain->m_radius;
  }
  break;

 case b2Shape::e_edge:
  {
   const b2EdgeShape* edge = static_cast<const b2EdgeShape*>(shape);
   m_vertices = &edge->m_vertex1;
   m_count = 2;
   m_radius = edge->m_radius;
  }
  break;

 default:
  ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 81, "false"));
 }
}


struct b2SimplexVertex
{
 b2Vec2 wA;
 b2Vec2 wB;
 b2Vec2 w;
 float32 a;
 int32 indexA;
 int32 indexB;
};

struct b2Simplex
{
 void ReadCache( const b2SimplexCache* cache,
     const b2DistanceProxy* proxyA, const b2Transform& transformA,
     const b2DistanceProxy* proxyB, const b2Transform& transformB)
 {
  ((cache->count <= 3) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 102, "cache->count <= 3"));


  m_count = cache->count;
  b2SimplexVertex* vertices = &m_v1;
  for (int32 i = 0; i < m_count; ++i)
  {
   b2SimplexVertex* v = vertices + i;
   v->indexA = cache->indexA[i];
   v->indexB = cache->indexB[i];
   b2Vec2 wALocal = proxyA->GetVertex(v->indexA);
   b2Vec2 wBLocal = proxyB->GetVertex(v->indexB);
   v->wA = b2Mul(transformA, wALocal);
   v->wB = b2Mul(transformB, wBLocal);
   v->w = v->wB - v->wA;
   v->a = 0.0f;
  }



  if (m_count > 1)
  {
   float32 metric1 = cache->metric;
   float32 metric2 = GetMetric();
   if (metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < 1.19209290e-7F)
   {

    m_count = 0;
   }
  }


  if (m_count == 0)
  {
   b2SimplexVertex* v = vertices + 0;
   v->indexA = 0;
   v->indexB = 0;
   b2Vec2 wALocal = proxyA->GetVertex(0);
   b2Vec2 wBLocal = proxyB->GetVertex(0);
   v->wA = b2Mul(transformA, wALocal);
   v->wB = b2Mul(transformB, wBLocal);
   v->w = v->wB - v->wA;
   v->a = 1.0f;
   m_count = 1;
  }
 }

 void WriteCache(b2SimplexCache* cache) const
 {
  cache->metric = GetMetric();
  cache->count = uint16(m_count);
  const b2SimplexVertex* vertices = &m_v1;
  for (int32 i = 0; i < m_count; ++i)
  {
   cache->indexA[i] = uint8(vertices[i].indexA);
   cache->indexB[i] = uint8(vertices[i].indexB);
  }
 }

 b2Vec2 GetSearchDirection() const
 {
  switch (m_count)
  {
  case 1:
   return -m_v1.w;

  case 2:
   {
    b2Vec2 e12 = m_v2.w - m_v1.w;
    float32 sgn = b2Cross(e12, -m_v1.w);
    if (sgn > 0.0f)
    {

     return b2Cross(1.0f, e12);
    }
    else
    {

     return b2Cross(e12, 1.0f);
    }
   }

  default:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 185, "false"));
   return b2Vec2_zero;
  }
 }

 b2Vec2 GetClosestPoint() const
 {
  switch (m_count)
  {
  case 0:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 195, "false"));
   return b2Vec2_zero;

  case 1:
   return m_v1.w;

  case 2:
   return m_v1.a * m_v1.w + m_v2.a * m_v2.w;

  case 3:
   return b2Vec2_zero;

  default:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 208, "false"));
   return b2Vec2_zero;
  }
 }

 void GetWitnessPoints(b2Vec2* pA, b2Vec2* pB) const
 {
  switch (m_count)
  {
  case 0:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 218, "false"));
   break;

  case 1:
   *pA = m_v1.wA;
   *pB = m_v1.wB;
   break;

  case 2:
   *pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA;
   *pB = m_v1.a * m_v1.wB + m_v2.a * m_v2.wB;
   break;

  case 3:
   *pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA + m_v3.a * m_v3.wA;
   *pB = *pA;
   break;

  default:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 237, "false"));
   break;
  }
 }

 float32 GetMetric() const
 {
  switch (m_count)
  {
  case 0:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 247, "false"));
   return 0.0f;

  case 1:
   return 0.0f;

  case 2:
   return b2Distance(m_v1.w, m_v2.w);

  case 3:
   return b2Cross(m_v2.w - m_v1.w, m_v3.w - m_v1.w);

  default:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 260, "false"));
   return 0.0f;
  }
 }

 void Solve2();
 void Solve3();

 b2SimplexVertex m_v1, m_v2, m_v3;
 int32 m_count;
};
# 296 "v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp"
void b2Simplex::Solve2()
{
 b2Vec2 w1 = m_v1.w;
 b2Vec2 w2 = m_v2.w;
 b2Vec2 e12 = w2 - w1;


 float32 d12_2 = -b2Dot(w1, e12);
 if (d12_2 <= 0.0f)
 {

  m_v1.a = 1.0f;
  m_count = 1;
  return;
 }


 float32 d12_1 = b2Dot(w2, e12);
 if (d12_1 <= 0.0f)
 {

  m_v2.a = 1.0f;
  m_count = 1;
  m_v1 = m_v2;
  return;
 }


 float32 inv_d12 = 1.0f / (d12_1 + d12_2);
 m_v1.a = d12_1 * inv_d12;
 m_v2.a = d12_2 * inv_d12;
 m_count = 2;
}






void b2Simplex::Solve3()
{
 b2Vec2 w1 = m_v1.w;
 b2Vec2 w2 = m_v2.w;
 b2Vec2 w3 = m_v3.w;





 b2Vec2 e12 = w2 - w1;
 float32 w1e12 = b2Dot(w1, e12);
 float32 w2e12 = b2Dot(w2, e12);
 float32 d12_1 = w2e12;
 float32 d12_2 = -w1e12;





 b2Vec2 e13 = w3 - w1;
 float32 w1e13 = b2Dot(w1, e13);
 float32 w3e13 = b2Dot(w3, e13);
 float32 d13_1 = w3e13;
 float32 d13_2 = -w1e13;





 b2Vec2 e23 = w3 - w2;
 float32 w2e23 = b2Dot(w2, e23);
 float32 w3e23 = b2Dot(w3, e23);
 float32 d23_1 = w3e23;
 float32 d23_2 = -w2e23;


 float32 n123 = b2Cross(e12, e13);

 float32 d123_1 = n123 * b2Cross(w2, w3);
 float32 d123_2 = n123 * b2Cross(w3, w1);
 float32 d123_3 = n123 * b2Cross(w1, w2);


 if (d12_2 <= 0.0f && d13_2 <= 0.0f)
 {
  m_v1.a = 1.0f;
  m_count = 1;
  return;
 }


 if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)
 {
  float32 inv_d12 = 1.0f / (d12_1 + d12_2);
  m_v1.a = d12_1 * inv_d12;
  m_v2.a = d12_2 * inv_d12;
  m_count = 2;
  return;
 }


 if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)
 {
  float32 inv_d13 = 1.0f / (d13_1 + d13_2);
  m_v1.a = d13_1 * inv_d13;
  m_v3.a = d13_2 * inv_d13;
  m_count = 2;
  m_v2 = m_v3;
  return;
 }


 if (d12_1 <= 0.0f && d23_2 <= 0.0f)
 {
  m_v2.a = 1.0f;
  m_count = 1;
  m_v1 = m_v2;
  return;
 }


 if (d13_1 <= 0.0f && d23_1 <= 0.0f)
 {
  m_v3.a = 1.0f;
  m_count = 1;
  m_v1 = m_v3;
  return;
 }


 if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)
 {
  float32 inv_d23 = 1.0f / (d23_1 + d23_2);
  m_v2.a = d23_1 * inv_d23;
  m_v3.a = d23_2 * inv_d23;
  m_count = 2;
  m_v1 = m_v3;
  return;
 }


 float32 inv_d123 = 1.0f / (d123_1 + d123_2 + d123_3);
 m_v1.a = d123_1 * inv_d123;
 m_v2.a = d123_2 * inv_d123;
 m_v3.a = d123_3 * inv_d123;
 m_count = 3;
}

void b2Distance(b2DistanceOutput* output,
    b2SimplexCache* cache,
    const b2DistanceInput* input)
{
 ++b2_gjkCalls;

 const b2DistanceProxy* proxyA = &input->proxyA;
 const b2DistanceProxy* proxyB = &input->proxyB;

 b2Transform transformA = input->transformA;
 b2Transform transformB = input->transformB;


 b2Simplex simplex;
 simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);


 b2SimplexVertex* vertices = &simplex.m_v1;
 const int32 k_maxIters = 20;



 int32 saveA[3], saveB[3];
 int32 saveCount = 0;

 float32 distanceSqr1 = 3.402823466e+38F;
 float32 distanceSqr2 = distanceSqr1;


 int32 iter = 0;
 while (iter < k_maxIters)
 {

  saveCount = simplex.m_count;
  for (int32 i = 0; i < saveCount; ++i)
  {
   saveA[i] = vertices[i].indexA;
   saveB[i] = vertices[i].indexB;
  }

  switch (simplex.m_count)
  {
  case 1:
   break;

  case 2:
   simplex.Solve2();
   break;

  case 3:
   simplex.Solve3();
   break;

  default:
   ((false) ? ((void)0) : __assert("v:/gigglingbits/box2d/Box2D/Collision/b2Distance.cpp", 498, "false"));
  }


  if (simplex.m_count == 3)
  {
   break;
  }


  b2Vec2 p = simplex.GetClosestPoint();
  distanceSqr2 = p.LengthSquared();


  if (distanceSqr2 >= distanceSqr1)
  {

  }
  distanceSqr1 = distanceSqr2;


  b2Vec2 d = simplex.GetSearchDirection();


  if (d.LengthSquared() < 1.19209290e-7F * 1.19209290e-7F)
  {






   break;
  }


  b2SimplexVertex* vertex = vertices + simplex.m_count;
  vertex->indexA = proxyA->GetSupport(b2MulT(transformA.q, -d));
  vertex->wA = b2Mul(transformA, proxyA->GetVertex(vertex->indexA));
  b2Vec2 wBLocal;
  vertex->indexB = proxyB->GetSupport(b2MulT(transformB.q, d));
  vertex->wB = b2Mul(transformB, proxyB->GetVertex(vertex->indexB));
  vertex->w = vertex->wB - vertex->wA;


  ++iter;
  ++b2_gjkIters;


  bool duplicate = false;
  for (int32 i = 0; i < saveCount; ++i)
  {
   if (vertex->indexA == saveA[i] && vertex->indexB == saveB[i])
   {
    duplicate = true;
    break;
   }
  }


  if (duplicate)
  {
   break;
  }


  ++simplex.m_count;
 }

 b2_gjkMaxIters = b2Max(b2_gjkMaxIters, iter);


 simplex.GetWitnessPoints(&output->pointA, &output->pointB);
 output->distance = b2Distance(output->pointA, output->pointB);
 output->iterations = iter;


 simplex.WriteCache(cache);


 if (input->useRadii)
 {
  float32 rA = proxyA->m_radius;
  float32 rB = proxyB->m_radius;

  if (output->distance > rA + rB && output->distance > 1.19209290e-7F)
  {


   output->distance -= rA + rB;
   b2Vec2 normal = output->pointB - output->pointA;
   normal.Normalize();
   output->pointA += rA * normal;
   output->pointB -= rB * normal;
  }
  else
  {


   b2Vec2 p = 0.5f * (output->pointA + output->pointB);
   output->pointA = p;
   output->pointB = p;
   output->distance = 0.0f;
  }
 }
}
